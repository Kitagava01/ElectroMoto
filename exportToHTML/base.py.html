<html>
<head>
<title>base.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #2aacb8;}
.s5 { color: #5f826b; font-style: italic;}
.s6 { color: #7a7e85;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
base.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">import </span><span class="s1">collections</span><span class="s2">.</span><span class="s1">abc </span><span class="s0">as </span><span class="s1">c</span>
<span class="s0">import </span><span class="s1">typing </span><span class="s0">as </span><span class="s1">t</span>
<span class="s0">import </span><span class="s1">warnings</span>
<span class="s0">import </span><span class="s1">weakref</span>
<span class="s0">from </span><span class="s1">collections </span><span class="s0">import </span><span class="s1">defaultdict</span>
<span class="s0">from </span><span class="s1">contextlib </span><span class="s0">import </span><span class="s1">AbstractContextManager</span>
<span class="s0">from </span><span class="s1">contextlib </span><span class="s0">import </span><span class="s1">contextmanager</span>
<span class="s0">from </span><span class="s1">functools </span><span class="s0">import </span><span class="s1">cached_property</span>
<span class="s0">from </span><span class="s1">inspect </span><span class="s0">import </span><span class="s1">iscoroutinefunction</span>
<span class="s0">from </span><span class="s1">weakref </span><span class="s0">import </span><span class="s1">WeakValueDictionary</span>

<span class="s0">from </span><span class="s2">.</span><span class="s1">_utilities </span><span class="s0">import </span><span class="s1">make_id</span>
<span class="s0">from </span><span class="s2">.</span><span class="s1">_utilities </span><span class="s0">import </span><span class="s1">make_ref</span>
<span class="s0">from </span><span class="s2">.</span><span class="s1">_utilities </span><span class="s0">import </span><span class="s1">Symbol</span>

<span class="s0">if </span><span class="s1">t</span><span class="s2">.</span><span class="s1">TYPE_CHECKING</span><span class="s2">:</span>
    <span class="s1">F </span><span class="s2">= </span><span class="s1">t</span><span class="s2">.</span><span class="s1">TypeVar</span><span class="s2">(</span><span class="s3">&quot;F&quot;</span><span class="s2">, </span><span class="s1">bound</span><span class="s2">=</span><span class="s1">c</span><span class="s2">.</span><span class="s1">Callable</span><span class="s2">[..., </span><span class="s1">t</span><span class="s2">.</span><span class="s1">Any</span><span class="s2">])</span>

<span class="s1">ANY </span><span class="s2">= </span><span class="s1">Symbol</span><span class="s2">(</span><span class="s3">&quot;ANY&quot;</span><span class="s2">)</span>
<span class="s3">&quot;&quot;&quot;Symbol for &quot;any sender&quot;.&quot;&quot;&quot;</span>

<span class="s1">ANY_ID </span><span class="s2">= </span><span class="s4">0</span>


<span class="s0">class </span><span class="s1">Signal</span><span class="s2">:</span>
    <span class="s5">&quot;&quot;&quot;A notification emitter. 
 
    :param doc: The docstring for the signal. 
    &quot;&quot;&quot;</span>

    <span class="s1">ANY </span><span class="s2">= </span><span class="s1">ANY</span>
    <span class="s3">&quot;&quot;&quot;An alias for the :data:`~blinker.ANY` sender symbol.&quot;&quot;&quot;</span>

    <span class="s1">set_class</span><span class="s2">: </span><span class="s1">type</span><span class="s2">[</span><span class="s1">set</span><span class="s2">[</span><span class="s1">t</span><span class="s2">.</span><span class="s1">Any</span><span class="s2">]] = </span><span class="s1">set</span>
    <span class="s3">&quot;&quot;&quot;The set class to use for tracking connected receivers and senders. 
    Python's ``set`` is unordered. If receivers must be dispatched in the order 
    they were connected, an ordered set implementation can be used. 
 
    .. versionadded:: 1.7 
    &quot;&quot;&quot;</span>

    <span class="s2">@</span><span class="s1">cached_property</span>
    <span class="s0">def </span><span class="s1">receiver_connected</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; Signal</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot;Emitted at the end of each :meth:`connect` call. 
 
        The signal sender is the signal instance, and the :meth:`connect` 
        arguments are passed through: ``receiver``, ``sender``, and ``weak``. 
 
        .. versionadded:: 1.2 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">Signal</span><span class="s2">(</span><span class="s1">doc</span><span class="s2">=</span><span class="s3">&quot;Emitted after a receiver connects.&quot;</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">cached_property</span>
    <span class="s0">def </span><span class="s1">receiver_disconnected</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; Signal</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot;Emitted at the end of each :meth:`disconnect` call. 
 
        The sender is the signal instance, and the :meth:`disconnect` arguments 
        are passed through: ``receiver`` and ``sender``. 
 
        This signal is emitted **only** when :meth:`disconnect` is called 
        explicitly. This signal cannot be emitted by an automatic disconnect 
        when a weakly referenced receiver or sender goes out of scope, as the 
        instance is no longer be available to be used as the sender for this 
        signal. 
 
        An alternative approach is available by subscribing to 
        :attr:`receiver_connected` and setting up a custom weakref cleanup 
        callback on weak receivers and senders. 
 
        .. versionadded:: 1.2 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">Signal</span><span class="s2">(</span><span class="s1">doc</span><span class="s2">=</span><span class="s3">&quot;Emitted after a receiver disconnects.&quot;</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">doc</span><span class="s2">: </span><span class="s1">str </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">doc</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">__doc__ </span><span class="s2">= </span><span class="s1">doc</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">receivers</span><span class="s2">: </span><span class="s1">dict</span><span class="s2">[</span>
            <span class="s1">t</span><span class="s2">.</span><span class="s1">Any</span><span class="s2">, </span><span class="s1">weakref</span><span class="s2">.</span><span class="s1">ref</span><span class="s2">[</span><span class="s1">c</span><span class="s2">.</span><span class="s1">Callable</span><span class="s2">[..., </span><span class="s1">t</span><span class="s2">.</span><span class="s1">Any</span><span class="s2">]] | </span><span class="s1">c</span><span class="s2">.</span><span class="s1">Callable</span><span class="s2">[..., </span><span class="s1">t</span><span class="s2">.</span><span class="s1">Any</span><span class="s2">]</span>
        <span class="s2">] = {}</span>
        <span class="s3">&quot;&quot;&quot;The map of connected receivers. Useful to quickly check if any 
        receivers are connected to the signal: ``if s.receivers:``. The 
        structure and data is not part of the public API, but checking its 
        boolean value is. 
        &quot;&quot;&quot;</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">is_muted</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_by_receiver</span><span class="s2">: </span><span class="s1">dict</span><span class="s2">[</span><span class="s1">t</span><span class="s2">.</span><span class="s1">Any</span><span class="s2">, </span><span class="s1">set</span><span class="s2">[</span><span class="s1">t</span><span class="s2">.</span><span class="s1">Any</span><span class="s2">]] = </span><span class="s1">defaultdict</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">set_class</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_by_sender</span><span class="s2">: </span><span class="s1">dict</span><span class="s2">[</span><span class="s1">t</span><span class="s2">.</span><span class="s1">Any</span><span class="s2">, </span><span class="s1">set</span><span class="s2">[</span><span class="s1">t</span><span class="s2">.</span><span class="s1">Any</span><span class="s2">]] = </span><span class="s1">defaultdict</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">set_class</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_weak_senders</span><span class="s2">: </span><span class="s1">dict</span><span class="s2">[</span><span class="s1">t</span><span class="s2">.</span><span class="s1">Any</span><span class="s2">, </span><span class="s1">weakref</span><span class="s2">.</span><span class="s1">ref</span><span class="s2">[</span><span class="s1">t</span><span class="s2">.</span><span class="s1">Any</span><span class="s2">]] = {}</span>

    <span class="s0">def </span><span class="s1">connect</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">receiver</span><span class="s2">: </span><span class="s1">F</span><span class="s2">, </span><span class="s1">sender</span><span class="s2">: </span><span class="s1">t</span><span class="s2">.</span><span class="s1">Any </span><span class="s2">= </span><span class="s1">ANY</span><span class="s2">, </span><span class="s1">weak</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">True</span><span class="s2">) </span><span class="s1">-&gt; F</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot;Connect ``receiver`` to be called when the signal is sent by 
        ``sender``. 
 
        :param receiver: The callable to call when :meth:`send` is called with 
            the given ``sender``, passing ``sender`` as a positional argument 
            along with any extra keyword arguments. 
        :param sender: Any object or :data:`ANY`. ``receiver`` will only be 
            called when :meth:`send` is called with this sender. If ``ANY``, the 
            receiver will be called for any sender. A receiver may be connected 
            to multiple senders by calling :meth:`connect` multiple times. 
        :param weak: Track the receiver with a :mod:`weakref`. The receiver will 
            be automatically disconnected when it is garbage collected. When 
            connecting a receiver defined within a function, set to ``False``, 
            otherwise it will be disconnected when the function scope ends. 
        &quot;&quot;&quot;</span>
        <span class="s1">receiver_id </span><span class="s2">= </span><span class="s1">make_id</span><span class="s2">(</span><span class="s1">receiver</span><span class="s2">)</span>
        <span class="s1">sender_id </span><span class="s2">= </span><span class="s1">ANY_ID </span><span class="s0">if </span><span class="s1">sender </span><span class="s0">is </span><span class="s1">ANY </span><span class="s0">else </span><span class="s1">make_id</span><span class="s2">(</span><span class="s1">sender</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">weak</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">receivers</span><span class="s2">[</span><span class="s1">receiver_id</span><span class="s2">] = </span><span class="s1">make_ref</span><span class="s2">(</span>
                <span class="s1">receiver</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_make_cleanup_receiver</span><span class="s2">(</span><span class="s1">receiver_id</span><span class="s2">)</span>
            <span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">receivers</span><span class="s2">[</span><span class="s1">receiver_id</span><span class="s2">] = </span><span class="s1">receiver</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">_by_sender</span><span class="s2">[</span><span class="s1">sender_id</span><span class="s2">].</span><span class="s1">add</span><span class="s2">(</span><span class="s1">receiver_id</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_by_receiver</span><span class="s2">[</span><span class="s1">receiver_id</span><span class="s2">].</span><span class="s1">add</span><span class="s2">(</span><span class="s1">sender_id</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">sender </span><span class="s0">is not </span><span class="s1">ANY </span><span class="s0">and </span><span class="s1">sender_id </span><span class="s0">not in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_weak_senders</span><span class="s2">:</span>
            <span class="s6"># store a cleanup for weakref-able senders</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_weak_senders</span><span class="s2">[</span><span class="s1">sender_id</span><span class="s2">] = </span><span class="s1">make_ref</span><span class="s2">(</span>
                    <span class="s1">sender</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_make_cleanup_sender</span><span class="s2">(</span><span class="s1">sender_id</span><span class="s2">)</span>
                <span class="s2">)</span>
            <span class="s0">except </span><span class="s1">TypeError</span><span class="s2">:</span>
                <span class="s0">pass</span>

        <span class="s0">if </span><span class="s3">&quot;receiver_connected&quot; </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__dict__ </span><span class="s0">and </span><span class="s1">self</span><span class="s2">.</span><span class="s1">receiver_connected</span><span class="s2">.</span><span class="s1">receivers</span><span class="s2">:</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">receiver_connected</span><span class="s2">.</span><span class="s1">send</span><span class="s2">(</span>
                    <span class="s1">self</span><span class="s2">, </span><span class="s1">receiver</span><span class="s2">=</span><span class="s1">receiver</span><span class="s2">, </span><span class="s1">sender</span><span class="s2">=</span><span class="s1">sender</span><span class="s2">, </span><span class="s1">weak</span><span class="s2">=</span><span class="s1">weak</span>
                <span class="s2">)</span>
            <span class="s0">except </span><span class="s1">TypeError</span><span class="s2">:</span>
                <span class="s6"># TODO no explanation or test for this</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">disconnect</span><span class="s2">(</span><span class="s1">receiver</span><span class="s2">, </span><span class="s1">sender</span><span class="s2">)</span>
                <span class="s0">raise</span>

        <span class="s0">if </span><span class="s1">_receiver_connected</span><span class="s2">.</span><span class="s1">receivers </span><span class="s0">and </span><span class="s1">self </span><span class="s0">is not </span><span class="s1">_receiver_connected</span><span class="s2">:</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s1">_receiver_connected</span><span class="s2">.</span><span class="s1">send</span><span class="s2">(</span>
                    <span class="s1">self</span><span class="s2">, </span><span class="s1">receiver_arg</span><span class="s2">=</span><span class="s1">receiver</span><span class="s2">, </span><span class="s1">sender_arg</span><span class="s2">=</span><span class="s1">sender</span><span class="s2">, </span><span class="s1">weak_arg</span><span class="s2">=</span><span class="s1">weak</span>
                <span class="s2">)</span>
            <span class="s0">except </span><span class="s1">TypeError</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">disconnect</span><span class="s2">(</span><span class="s1">receiver</span><span class="s2">, </span><span class="s1">sender</span><span class="s2">)</span>
                <span class="s0">raise</span>

        <span class="s0">return </span><span class="s1">receiver</span>

    <span class="s0">def </span><span class="s1">connect_via</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">sender</span><span class="s2">: </span><span class="s1">t</span><span class="s2">.</span><span class="s1">Any</span><span class="s2">, </span><span class="s1">weak</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">) </span><span class="s1">-&gt; c</span><span class="s2">.</span><span class="s1">Callable</span><span class="s2">[[</span><span class="s1">F</span><span class="s2">], </span><span class="s1">F</span><span class="s2">]:</span>
        <span class="s5">&quot;&quot;&quot;Connect the decorated function to be called when the signal is sent 
        by ``sender``. 
 
        The decorated function will be called when :meth:`send` is called with 
        the given ``sender``, passing ``sender`` as a positional argument along 
        with any extra keyword arguments. 
 
        :param sender: Any object or :data:`ANY`. ``receiver`` will only be 
            called when :meth:`send` is called with this sender. If ``ANY``, the 
            receiver will be called for any sender. A receiver may be connected 
            to multiple senders by calling :meth:`connect` multiple times. 
        :param weak: Track the receiver with a :mod:`weakref`. The receiver will 
            be automatically disconnected when it is garbage collected. When 
            connecting a receiver defined within a function, set to ``False``, 
            otherwise it will be disconnected when the function scope ends.= 
 
        .. versionadded:: 1.1 
        &quot;&quot;&quot;</span>

        <span class="s0">def </span><span class="s1">decorator</span><span class="s2">(</span><span class="s1">fn</span><span class="s2">: </span><span class="s1">F</span><span class="s2">) </span><span class="s1">-&gt; F</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">connect</span><span class="s2">(</span><span class="s1">fn</span><span class="s2">, </span><span class="s1">sender</span><span class="s2">, </span><span class="s1">weak</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">fn</span>

        <span class="s0">return </span><span class="s1">decorator</span>

    <span class="s2">@</span><span class="s1">contextmanager</span>
    <span class="s0">def </span><span class="s1">connected_to</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">receiver</span><span class="s2">: </span><span class="s1">c</span><span class="s2">.</span><span class="s1">Callable</span><span class="s2">[..., </span><span class="s1">t</span><span class="s2">.</span><span class="s1">Any</span><span class="s2">], </span><span class="s1">sender</span><span class="s2">: </span><span class="s1">t</span><span class="s2">.</span><span class="s1">Any </span><span class="s2">= </span><span class="s1">ANY</span>
    <span class="s2">) </span><span class="s1">-&gt; c</span><span class="s2">.</span><span class="s1">Generator</span><span class="s2">[</span><span class="s0">None</span><span class="s2">, </span><span class="s0">None</span><span class="s2">, </span><span class="s0">None</span><span class="s2">]:</span>
        <span class="s5">&quot;&quot;&quot;A context manager that temporarily connects ``receiver`` to the 
        signal while a ``with`` block executes. When the block exits, the 
        receiver is disconnected. Useful for tests. 
 
        :param receiver: The callable to call when :meth:`send` is called with 
            the given ``sender``, passing ``sender`` as a positional argument 
            along with any extra keyword arguments. 
        :param sender: Any object or :data:`ANY`. ``receiver`` will only be 
            called when :meth:`send` is called with this sender. If ``ANY``, the 
            receiver will be called for any sender. 
 
        .. versionadded:: 1.1 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">connect</span><span class="s2">(</span><span class="s1">receiver</span><span class="s2">, </span><span class="s1">sender</span><span class="s2">=</span><span class="s1">sender</span><span class="s2">, </span><span class="s1">weak</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>

        <span class="s0">try</span><span class="s2">:</span>
            <span class="s0">yield None</span>
        <span class="s0">finally</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">disconnect</span><span class="s2">(</span><span class="s1">receiver</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">contextmanager</span>
    <span class="s0">def </span><span class="s1">muted</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; c</span><span class="s2">.</span><span class="s1">Generator</span><span class="s2">[</span><span class="s0">None</span><span class="s2">, </span><span class="s0">None</span><span class="s2">, </span><span class="s0">None</span><span class="s2">]:</span>
        <span class="s5">&quot;&quot;&quot;A context manager that temporarily disables the signal. No receivers 
        will be called if the signal is sent, until the ``with`` block exits. 
        Useful for tests. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">is_muted </span><span class="s2">= </span><span class="s0">True</span>

        <span class="s0">try</span><span class="s2">:</span>
            <span class="s0">yield None</span>
        <span class="s0">finally</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">is_muted </span><span class="s2">= </span><span class="s0">False</span>

    <span class="s0">def </span><span class="s1">temporarily_connected_to</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">receiver</span><span class="s2">: </span><span class="s1">c</span><span class="s2">.</span><span class="s1">Callable</span><span class="s2">[..., </span><span class="s1">t</span><span class="s2">.</span><span class="s1">Any</span><span class="s2">], </span><span class="s1">sender</span><span class="s2">: </span><span class="s1">t</span><span class="s2">.</span><span class="s1">Any </span><span class="s2">= </span><span class="s1">ANY</span>
    <span class="s2">) </span><span class="s1">-&gt; AbstractContextManager</span><span class="s2">[</span><span class="s0">None</span><span class="s2">]:</span>
        <span class="s5">&quot;&quot;&quot;Deprecated alias for :meth:`connected_to`. 
 
        .. deprecated:: 1.1 
            Renamed to ``connected_to``. Will be removed in Blinker 1.9. 
 
        .. versionadded:: 0.9 
        &quot;&quot;&quot;</span>
        <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span>
            <span class="s3">&quot;'temporarily_connected_to' is renamed to 'connected_to'. The old name is&quot;</span>
            <span class="s3">&quot; deprecated and will be removed in Blinker 1.9.&quot;</span><span class="s2">,</span>
            <span class="s1">DeprecationWarning</span><span class="s2">,</span>
            <span class="s1">stacklevel</span><span class="s2">=</span><span class="s4">2</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">connected_to</span><span class="s2">(</span><span class="s1">receiver</span><span class="s2">, </span><span class="s1">sender</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">send</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">sender</span><span class="s2">: </span><span class="s1">t</span><span class="s2">.</span><span class="s1">Any </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s2">/,</span>
        <span class="s2">*,</span>
        <span class="s1">_async_wrapper</span><span class="s2">: </span><span class="s1">c</span><span class="s2">.</span><span class="s1">Callable</span><span class="s2">[</span>
            <span class="s2">[</span><span class="s1">c</span><span class="s2">.</span><span class="s1">Callable</span><span class="s2">[..., </span><span class="s1">c</span><span class="s2">.</span><span class="s1">Coroutine</span><span class="s2">[</span><span class="s1">t</span><span class="s2">.</span><span class="s1">Any</span><span class="s2">, </span><span class="s1">t</span><span class="s2">.</span><span class="s1">Any</span><span class="s2">, </span><span class="s1">t</span><span class="s2">.</span><span class="s1">Any</span><span class="s2">]]], </span><span class="s1">c</span><span class="s2">.</span><span class="s1">Callable</span><span class="s2">[..., </span><span class="s1">t</span><span class="s2">.</span><span class="s1">Any</span><span class="s2">]</span>
        <span class="s2">]</span>
        <span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s2">**</span><span class="s1">kwargs</span><span class="s2">: </span><span class="s1">t</span><span class="s2">.</span><span class="s1">Any</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; list</span><span class="s2">[</span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">c</span><span class="s2">.</span><span class="s1">Callable</span><span class="s2">[..., </span><span class="s1">t</span><span class="s2">.</span><span class="s1">Any</span><span class="s2">], </span><span class="s1">t</span><span class="s2">.</span><span class="s1">Any</span><span class="s2">]]:</span>
        <span class="s5">&quot;&quot;&quot;Call all receivers that are connected to the given ``sender`` 
        or :data:`ANY`. Each receiver is called with ``sender`` as a positional 
        argument along with any extra keyword arguments. Return a list of 
        ``(receiver, return value)`` tuples. 
 
        The order receivers are called is undefined, but can be influenced by 
        setting :attr:`set_class`. 
 
        If a receiver raises an exception, that exception will propagate up. 
        This makes debugging straightforward, with an assumption that correctly 
        implemented receivers will not raise. 
 
        :param sender: Call receivers connected to this sender, in addition to 
            those connected to :data:`ANY`. 
        :param _async_wrapper: Will be called on any receivers that are async 
            coroutines to turn them into sync callables. For example, could run 
            the receiver with an event loop. 
        :param kwargs: Extra keyword arguments to pass to each receiver. 
 
        .. versionchanged:: 1.7 
            Added the ``_async_wrapper`` argument. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">is_muted</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s2">[]</span>

        <span class="s1">results </span><span class="s2">= []</span>

        <span class="s0">for </span><span class="s1">receiver </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">receivers_for</span><span class="s2">(</span><span class="s1">sender</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">iscoroutinefunction</span><span class="s2">(</span><span class="s1">receiver</span><span class="s2">):</span>
                <span class="s0">if </span><span class="s1">_async_wrapper </span><span class="s0">is None</span><span class="s2">:</span>
                    <span class="s0">raise </span><span class="s1">RuntimeError</span><span class="s2">(</span><span class="s3">&quot;Cannot send to a coroutine function.&quot;</span><span class="s2">)</span>

                <span class="s1">result </span><span class="s2">= </span><span class="s1">_async_wrapper</span><span class="s2">(</span><span class="s1">receiver</span><span class="s2">)(</span><span class="s1">sender</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">result </span><span class="s2">= </span><span class="s1">receiver</span><span class="s2">(</span><span class="s1">sender</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

            <span class="s1">results</span><span class="s2">.</span><span class="s1">append</span><span class="s2">((</span><span class="s1">receiver</span><span class="s2">, </span><span class="s1">result</span><span class="s2">))</span>

        <span class="s0">return </span><span class="s1">results</span>

    <span class="s0">async def </span><span class="s1">send_async</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">sender</span><span class="s2">: </span><span class="s1">t</span><span class="s2">.</span><span class="s1">Any </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s2">/,</span>
        <span class="s2">*,</span>
        <span class="s1">_sync_wrapper</span><span class="s2">: </span><span class="s1">c</span><span class="s2">.</span><span class="s1">Callable</span><span class="s2">[</span>
            <span class="s2">[</span><span class="s1">c</span><span class="s2">.</span><span class="s1">Callable</span><span class="s2">[..., </span><span class="s1">t</span><span class="s2">.</span><span class="s1">Any</span><span class="s2">]], </span><span class="s1">c</span><span class="s2">.</span><span class="s1">Callable</span><span class="s2">[..., </span><span class="s1">c</span><span class="s2">.</span><span class="s1">Coroutine</span><span class="s2">[</span><span class="s1">t</span><span class="s2">.</span><span class="s1">Any</span><span class="s2">, </span><span class="s1">t</span><span class="s2">.</span><span class="s1">Any</span><span class="s2">, </span><span class="s1">t</span><span class="s2">.</span><span class="s1">Any</span><span class="s2">]]</span>
        <span class="s2">]</span>
        <span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s2">**</span><span class="s1">kwargs</span><span class="s2">: </span><span class="s1">t</span><span class="s2">.</span><span class="s1">Any</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; list</span><span class="s2">[</span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">c</span><span class="s2">.</span><span class="s1">Callable</span><span class="s2">[..., </span><span class="s1">t</span><span class="s2">.</span><span class="s1">Any</span><span class="s2">], </span><span class="s1">t</span><span class="s2">.</span><span class="s1">Any</span><span class="s2">]]:</span>
        <span class="s5">&quot;&quot;&quot;Await all receivers that are connected to the given ``sender`` 
        or :data:`ANY`. Each receiver is called with ``sender`` as a positional 
        argument along with any extra keyword arguments. Return a list of 
        ``(receiver, return value)`` tuples. 
 
        The order receivers are called is undefined, but can be influenced by 
        setting :attr:`set_class`. 
 
        If a receiver raises an exception, that exception will propagate up. 
        This makes debugging straightforward, with an assumption that correctly 
        implemented receivers will not raise. 
 
        :param sender: Call receivers connected to this sender, in addition to 
            those connected to :data:`ANY`. 
        :param _sync_wrapper: Will be called on any receivers that are sync 
            callables to turn them into async coroutines. For example, 
            could call the receiver in a thread. 
        :param kwargs: Extra keyword arguments to pass to each receiver. 
 
        .. versionadded:: 1.7 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">is_muted</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s2">[]</span>

        <span class="s1">results </span><span class="s2">= []</span>

        <span class="s0">for </span><span class="s1">receiver </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">receivers_for</span><span class="s2">(</span><span class="s1">sender</span><span class="s2">):</span>
            <span class="s0">if not </span><span class="s1">iscoroutinefunction</span><span class="s2">(</span><span class="s1">receiver</span><span class="s2">):</span>
                <span class="s0">if </span><span class="s1">_sync_wrapper </span><span class="s0">is None</span><span class="s2">:</span>
                    <span class="s0">raise </span><span class="s1">RuntimeError</span><span class="s2">(</span><span class="s3">&quot;Cannot send to a non-coroutine function.&quot;</span><span class="s2">)</span>

                <span class="s1">result </span><span class="s2">= </span><span class="s0">await </span><span class="s1">_sync_wrapper</span><span class="s2">(</span><span class="s1">receiver</span><span class="s2">)(</span><span class="s1">sender</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">result </span><span class="s2">= </span><span class="s0">await </span><span class="s1">receiver</span><span class="s2">(</span><span class="s1">sender</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

            <span class="s1">results</span><span class="s2">.</span><span class="s1">append</span><span class="s2">((</span><span class="s1">receiver</span><span class="s2">, </span><span class="s1">result</span><span class="s2">))</span>

        <span class="s0">return </span><span class="s1">results</span>

    <span class="s0">def </span><span class="s1">has_receivers_for</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">sender</span><span class="s2">: </span><span class="s1">t</span><span class="s2">.</span><span class="s1">Any</span><span class="s2">) </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot;Check if there is at least one receiver that will be called with the 
        given ``sender``. A receiver connected to :data:`ANY` will always be 
        called, regardless of sender. Does not check if weakly referenced 
        receivers are still live. See :meth:`receivers_for` for a stronger 
        search. 
 
        :param sender: Check for receivers connected to this sender, in addition 
            to those connected to :data:`ANY`. 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">receivers</span><span class="s2">:</span>
            <span class="s0">return False</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_by_sender</span><span class="s2">[</span><span class="s1">ANY_ID</span><span class="s2">]:</span>
            <span class="s0">return True</span>

        <span class="s0">if </span><span class="s1">sender </span><span class="s0">is </span><span class="s1">ANY</span><span class="s2">:</span>
            <span class="s0">return False</span>

        <span class="s0">return </span><span class="s1">make_id</span><span class="s2">(</span><span class="s1">sender</span><span class="s2">) </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_by_sender</span>

    <span class="s0">def </span><span class="s1">receivers_for</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">sender</span><span class="s2">: </span><span class="s1">t</span><span class="s2">.</span><span class="s1">Any</span>
    <span class="s2">) </span><span class="s1">-&gt; c</span><span class="s2">.</span><span class="s1">Generator</span><span class="s2">[</span><span class="s1">c</span><span class="s2">.</span><span class="s1">Callable</span><span class="s2">[..., </span><span class="s1">t</span><span class="s2">.</span><span class="s1">Any</span><span class="s2">], </span><span class="s0">None</span><span class="s2">, </span><span class="s0">None</span><span class="s2">]:</span>
        <span class="s5">&quot;&quot;&quot;Yield each receiver to be called for ``sender``, in addition to those 
        to be called for :data:`ANY`. Weakly referenced receivers that are not 
        live will be disconnected and skipped. 
 
        :param sender: Yield receivers connected to this sender, in addition 
            to those connected to :data:`ANY`. 
        &quot;&quot;&quot;</span>
        <span class="s6"># TODO: test receivers_for(ANY)</span>
        <span class="s0">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">receivers</span><span class="s2">:</span>
            <span class="s0">return</span>

        <span class="s1">sender_id </span><span class="s2">= </span><span class="s1">make_id</span><span class="s2">(</span><span class="s1">sender</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">sender_id </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_by_sender</span><span class="s2">:</span>
            <span class="s1">ids </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_by_sender</span><span class="s2">[</span><span class="s1">ANY_ID</span><span class="s2">] | </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_by_sender</span><span class="s2">[</span><span class="s1">sender_id</span><span class="s2">]</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">ids </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_by_sender</span><span class="s2">[</span><span class="s1">ANY_ID</span><span class="s2">].</span><span class="s1">copy</span><span class="s2">()</span>

        <span class="s0">for </span><span class="s1">receiver_id </span><span class="s0">in </span><span class="s1">ids</span><span class="s2">:</span>
            <span class="s1">receiver </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">receivers</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">receiver_id</span><span class="s2">)</span>

            <span class="s0">if </span><span class="s1">receiver </span><span class="s0">is None</span><span class="s2">:</span>
                <span class="s0">continue</span>

            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">receiver</span><span class="s2">, </span><span class="s1">weakref</span><span class="s2">.</span><span class="s1">ref</span><span class="s2">):</span>
                <span class="s1">strong </span><span class="s2">= </span><span class="s1">receiver</span><span class="s2">()</span>

                <span class="s0">if </span><span class="s1">strong </span><span class="s0">is None</span><span class="s2">:</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">_disconnect</span><span class="s2">(</span><span class="s1">receiver_id</span><span class="s2">, </span><span class="s1">ANY_ID</span><span class="s2">)</span>
                    <span class="s0">continue</span>

                <span class="s0">yield </span><span class="s1">strong</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">yield </span><span class="s1">receiver</span>

    <span class="s0">def </span><span class="s1">disconnect</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">receiver</span><span class="s2">: </span><span class="s1">c</span><span class="s2">.</span><span class="s1">Callable</span><span class="s2">[..., </span><span class="s1">t</span><span class="s2">.</span><span class="s1">Any</span><span class="s2">], </span><span class="s1">sender</span><span class="s2">: </span><span class="s1">t</span><span class="s2">.</span><span class="s1">Any </span><span class="s2">= </span><span class="s1">ANY</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot;Disconnect ``receiver`` from being called when the signal is sent by 
        ``sender``. 
 
        :param receiver: A connected receiver callable. 
        :param sender: Disconnect from only this sender. By default, disconnect 
            from all senders. 
        &quot;&quot;&quot;</span>
        <span class="s1">sender_id</span><span class="s2">: </span><span class="s1">c</span><span class="s2">.</span><span class="s1">Hashable</span>

        <span class="s0">if </span><span class="s1">sender </span><span class="s0">is </span><span class="s1">ANY</span><span class="s2">:</span>
            <span class="s1">sender_id </span><span class="s2">= </span><span class="s1">ANY_ID</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">sender_id </span><span class="s2">= </span><span class="s1">make_id</span><span class="s2">(</span><span class="s1">sender</span><span class="s2">)</span>

        <span class="s1">receiver_id </span><span class="s2">= </span><span class="s1">make_id</span><span class="s2">(</span><span class="s1">receiver</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_disconnect</span><span class="s2">(</span><span class="s1">receiver_id</span><span class="s2">, </span><span class="s1">sender_id</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s2">(</span>
            <span class="s3">&quot;receiver_disconnected&quot; </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__dict__</span>
            <span class="s0">and </span><span class="s1">self</span><span class="s2">.</span><span class="s1">receiver_disconnected</span><span class="s2">.</span><span class="s1">receivers</span>
        <span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">receiver_disconnected</span><span class="s2">.</span><span class="s1">send</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">receiver</span><span class="s2">=</span><span class="s1">receiver</span><span class="s2">, </span><span class="s1">sender</span><span class="s2">=</span><span class="s1">sender</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_disconnect</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">receiver_id</span><span class="s2">: </span><span class="s1">c</span><span class="s2">.</span><span class="s1">Hashable</span><span class="s2">, </span><span class="s1">sender_id</span><span class="s2">: </span><span class="s1">c</span><span class="s2">.</span><span class="s1">Hashable</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">sender_id </span><span class="s2">== </span><span class="s1">ANY_ID</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_by_receiver</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">(</span><span class="s1">receiver_id</span><span class="s2">, </span><span class="s0">None</span><span class="s2">) </span><span class="s0">is not None</span><span class="s2">:</span>
                <span class="s0">for </span><span class="s1">bucket </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_by_sender</span><span class="s2">.</span><span class="s1">values</span><span class="s2">():</span>
                    <span class="s1">bucket</span><span class="s2">.</span><span class="s1">discard</span><span class="s2">(</span><span class="s1">receiver_id</span><span class="s2">)</span>

            <span class="s1">self</span><span class="s2">.</span><span class="s1">receivers</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">(</span><span class="s1">receiver_id</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_by_sender</span><span class="s2">[</span><span class="s1">sender_id</span><span class="s2">].</span><span class="s1">discard</span><span class="s2">(</span><span class="s1">receiver_id</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_by_receiver</span><span class="s2">[</span><span class="s1">receiver_id</span><span class="s2">].</span><span class="s1">discard</span><span class="s2">(</span><span class="s1">sender_id</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_make_cleanup_receiver</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">receiver_id</span><span class="s2">: </span><span class="s1">c</span><span class="s2">.</span><span class="s1">Hashable</span>
    <span class="s2">) </span><span class="s1">-&gt; c</span><span class="s2">.</span><span class="s1">Callable</span><span class="s2">[[</span><span class="s1">weakref</span><span class="s2">.</span><span class="s1">ref</span><span class="s2">[</span><span class="s1">c</span><span class="s2">.</span><span class="s1">Callable</span><span class="s2">[..., </span><span class="s1">t</span><span class="s2">.</span><span class="s1">Any</span><span class="s2">]]], </span><span class="s0">None</span><span class="s2">]:</span>
        <span class="s5">&quot;&quot;&quot;Create a callback function to disconnect a weakly referenced 
        receiver when it is garbage collected. 
        &quot;&quot;&quot;</span>

        <span class="s0">def </span><span class="s1">cleanup</span><span class="s2">(</span><span class="s1">ref</span><span class="s2">: </span><span class="s1">weakref</span><span class="s2">.</span><span class="s1">ref</span><span class="s2">[</span><span class="s1">c</span><span class="s2">.</span><span class="s1">Callable</span><span class="s2">[..., </span><span class="s1">t</span><span class="s2">.</span><span class="s1">Any</span><span class="s2">]]) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_disconnect</span><span class="s2">(</span><span class="s1">receiver_id</span><span class="s2">, </span><span class="s1">ANY_ID</span><span class="s2">)</span>

        <span class="s0">return </span><span class="s1">cleanup</span>

    <span class="s0">def </span><span class="s1">_make_cleanup_sender</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">sender_id</span><span class="s2">: </span><span class="s1">c</span><span class="s2">.</span><span class="s1">Hashable</span>
    <span class="s2">) </span><span class="s1">-&gt; c</span><span class="s2">.</span><span class="s1">Callable</span><span class="s2">[[</span><span class="s1">weakref</span><span class="s2">.</span><span class="s1">ref</span><span class="s2">[</span><span class="s1">t</span><span class="s2">.</span><span class="s1">Any</span><span class="s2">]], </span><span class="s0">None</span><span class="s2">]:</span>
        <span class="s5">&quot;&quot;&quot;Create a callback function to disconnect all receivers for a weakly 
        referenced sender when it is garbage collected. 
        &quot;&quot;&quot;</span>
        <span class="s0">assert </span><span class="s1">sender_id </span><span class="s2">!= </span><span class="s1">ANY_ID</span>

        <span class="s0">def </span><span class="s1">cleanup</span><span class="s2">(</span><span class="s1">ref</span><span class="s2">: </span><span class="s1">weakref</span><span class="s2">.</span><span class="s1">ref</span><span class="s2">[</span><span class="s1">t</span><span class="s2">.</span><span class="s1">Any</span><span class="s2">]) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_weak_senders</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">(</span><span class="s1">sender_id</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>

            <span class="s0">for </span><span class="s1">receiver_id </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_by_sender</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">(</span><span class="s1">sender_id</span><span class="s2">, ()):</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_by_receiver</span><span class="s2">[</span><span class="s1">receiver_id</span><span class="s2">].</span><span class="s1">discard</span><span class="s2">(</span><span class="s1">sender_id</span><span class="s2">)</span>

        <span class="s0">return </span><span class="s1">cleanup</span>

    <span class="s0">def </span><span class="s1">_cleanup_bookkeeping</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot;Prune unused sender/receiver bookkeeping. Not threadsafe. 
 
        Connecting &amp; disconnecting leaves behind a small amount of bookkeeping 
        data. Typical workloads using Blinker, for example in most web apps, 
        Flask, CLI scripts, etc., are not adversely affected by this 
        bookkeeping. 
 
        With a long-running process performing dynamic signal routing with high 
        volume, e.g. connecting to function closures, senders are all unique 
        object instances. Doing all of this over and over may cause memory usage 
        to grow due to extraneous bookkeeping. (An empty ``set`` for each stale 
        sender/receiver pair.) 
 
        This method will prune that bookkeeping away, with the caveat that such 
        pruning is not threadsafe. The risk is that cleanup of a fully 
        disconnected receiver/sender pair occurs while another thread is 
        connecting that same pair. If you are in the highly dynamic, unique 
        receiver/sender situation that has lead you to this method, that failure 
        mode is perhaps not a big deal for you. 
        &quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">mapping </span><span class="s0">in </span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_by_sender</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_by_receiver</span><span class="s2">):</span>
            <span class="s0">for </span><span class="s1">ident</span><span class="s2">, </span><span class="s1">bucket </span><span class="s0">in </span><span class="s1">list</span><span class="s2">(</span><span class="s1">mapping</span><span class="s2">.</span><span class="s1">items</span><span class="s2">()):</span>
                <span class="s0">if not </span><span class="s1">bucket</span><span class="s2">:</span>
                    <span class="s1">mapping</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">(</span><span class="s1">ident</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_clear_state</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot;Disconnect all receivers and senders. Useful for tests.&quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_weak_senders</span><span class="s2">.</span><span class="s1">clear</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">receivers</span><span class="s2">.</span><span class="s1">clear</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_by_sender</span><span class="s2">.</span><span class="s1">clear</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_by_receiver</span><span class="s2">.</span><span class="s1">clear</span><span class="s2">()</span>


<span class="s1">_receiver_connected </span><span class="s2">= </span><span class="s1">Signal</span><span class="s2">(</span>
    <span class="s3">&quot;&quot;&quot;</span><span class="s0">\ 
</span><span class="s3">Sent by a :class:`Signal` after a receiver connects. 
 
:argument: the Signal that was connected to 
:keyword receiver_arg: the connected receiver 
:keyword sender_arg: the sender to connect to 
:keyword weak_arg: true if the connection to receiver_arg is a weak reference 
 
.. deprecated:: 1.2 
    Individual signals have their own :attr:`~Signal.receiver_connected` and 
    :attr:`~Signal.receiver_disconnected` signals with a slightly simplified 
    call signature. This global signal will be removed in Blinker 1.9. 
&quot;&quot;&quot;</span>
<span class="s2">)</span>


<span class="s0">class </span><span class="s1">NamedSignal</span><span class="s2">(</span><span class="s1">Signal</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot;A named generic notification emitter. The name is not used by the signal 
    itself, but matches the key in the :class:`Namespace` that it belongs to. 
 
    :param name: The name of the signal within the namespace. 
    :param doc: The docstring for the signal. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">str</span><span class="s2">, </span><span class="s1">doc</span><span class="s2">: </span><span class="s1">str </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">doc</span><span class="s2">)</span>

        <span class="s6">#: The name of this signal.</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">name</span><span class="s2">: </span><span class="s1">str </span><span class="s2">= </span><span class="s1">name</span>

    <span class="s0">def </span><span class="s1">__repr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; str</span><span class="s2">:</span>
        <span class="s1">base </span><span class="s2">= </span><span class="s1">super</span><span class="s2">().</span><span class="s1">__repr__</span><span class="s2">()</span>
        <span class="s0">return </span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">base</span><span class="s2">[:-</span><span class="s4">1</span><span class="s2">]</span><span class="s0">}</span><span class="s3">; </span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">name</span><span class="s0">!r}</span><span class="s3">&gt;&quot;  </span><span class="s6"># noqa: E702</span>


<span class="s0">if </span><span class="s1">t</span><span class="s2">.</span><span class="s1">TYPE_CHECKING</span><span class="s2">:</span>

    <span class="s0">class </span><span class="s1">PNamespaceSignal</span><span class="s2">(</span><span class="s1">t</span><span class="s2">.</span><span class="s1">Protocol</span><span class="s2">):</span>
        <span class="s0">def </span><span class="s1">__call__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">str</span><span class="s2">, </span><span class="s1">doc</span><span class="s2">: </span><span class="s1">str </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">) </span><span class="s1">-&gt; NamedSignal</span><span class="s2">: ...</span>

    <span class="s6"># Python &lt; 3.9</span>
    <span class="s1">_NamespaceBase </span><span class="s2">= </span><span class="s1">dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">NamedSignal</span><span class="s2">]  </span><span class="s6"># type: ignore[misc]</span>
<span class="s0">else</span><span class="s2">:</span>
    <span class="s1">_NamespaceBase </span><span class="s2">= </span><span class="s1">dict</span>


<span class="s0">class </span><span class="s1">Namespace</span><span class="s2">(</span><span class="s1">_NamespaceBase</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot;A dict mapping names to signals.&quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">signal</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">str</span><span class="s2">, </span><span class="s1">doc</span><span class="s2">: </span><span class="s1">str </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">) </span><span class="s1">-&gt; NamedSignal</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot;Return the :class:`NamedSignal` for the given ``name``, creating it 
        if required. Repeated calls with the same name return the same signal. 
 
        :param name: The name of the signal. 
        :param doc: The docstring of the signal. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">name </span><span class="s0">not in </span><span class="s1">self</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">[</span><span class="s1">name</span><span class="s2">] = </span><span class="s1">NamedSignal</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">doc</span><span class="s2">)</span>

        <span class="s0">return </span><span class="s1">self</span><span class="s2">[</span><span class="s1">name</span><span class="s2">]</span>


<span class="s0">class </span><span class="s1">_WeakNamespace</span><span class="s2">(</span><span class="s1">WeakValueDictionary</span><span class="s2">):  </span><span class="s6"># type: ignore[type-arg]</span>
    <span class="s5">&quot;&quot;&quot;A weak mapping of names to signals. 
 
    Automatically cleans up unused signals when the last reference goes out 
    of scope. This namespace implementation provides similar behavior to Blinker 
    &lt;= 1.2. 
 
    .. deprecated:: 1.3 
        Will be removed in Blinker 1.9. 
 
    .. versionadded:: 1.3 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span>
            <span class="s3">&quot;'WeakNamespace' is deprecated and will be removed in Blinker 1.9.&quot;</span>
            <span class="s3">&quot; Use 'Namespace' instead.&quot;</span><span class="s2">,</span>
            <span class="s1">DeprecationWarning</span><span class="s2">,</span>
            <span class="s1">stacklevel</span><span class="s2">=</span><span class="s4">2</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">signal</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">str</span><span class="s2">, </span><span class="s1">doc</span><span class="s2">: </span><span class="s1">str </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">) </span><span class="s1">-&gt; NamedSignal</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot;Return the :class:`NamedSignal` for the given ``name``, creating it 
        if required. Repeated calls with the same name return the same signal. 
 
        :param name: The name of the signal. 
        :param doc: The docstring of the signal. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">name </span><span class="s0">not in </span><span class="s1">self</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">[</span><span class="s1">name</span><span class="s2">] = </span><span class="s1">NamedSignal</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">doc</span><span class="s2">)</span>

        <span class="s0">return </span><span class="s1">self</span><span class="s2">[</span><span class="s1">name</span><span class="s2">]  </span><span class="s6"># type: ignore[no-any-return]</span>


<span class="s1">default_namespace</span><span class="s2">: </span><span class="s1">Namespace </span><span class="s2">= </span><span class="s1">Namespace</span><span class="s2">()</span>
<span class="s3">&quot;&quot;&quot;A default :class:`Namespace` for creating named signals. :func:`signal` 
creates a :class:`NamedSignal` in this namespace. 
&quot;&quot;&quot;</span>

<span class="s1">signal</span><span class="s2">: </span><span class="s1">PNamespaceSignal </span><span class="s2">= </span><span class="s1">default_namespace</span><span class="s2">.</span><span class="s1">signal</span>
<span class="s3">&quot;&quot;&quot;Return a :class:`NamedSignal` in :data:`default_namespace` with the given 
``name``, creating it if required. Repeated calls with the same name return the 
same signal. 
&quot;&quot;&quot;</span>


<span class="s0">def </span><span class="s1">__getattr__</span><span class="s2">(</span><span class="s1">name</span><span class="s2">: </span><span class="s1">str</span><span class="s2">) </span><span class="s1">-&gt; t</span><span class="s2">.</span><span class="s1">Any</span><span class="s2">:</span>
    <span class="s0">if </span><span class="s1">name </span><span class="s2">== </span><span class="s3">&quot;receiver_connected&quot;</span><span class="s2">:</span>
        <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span>
            <span class="s3">&quot;The global 'receiver_connected' signal is deprecated and will be&quot;</span>
            <span class="s3">&quot; removed in Blinker 1.9. Use 'Signal.receiver_connected' and&quot;</span>
            <span class="s3">&quot; 'Signal.receiver_disconnected' instead.&quot;</span><span class="s2">,</span>
            <span class="s1">DeprecationWarning</span><span class="s2">,</span>
            <span class="s1">stacklevel</span><span class="s2">=</span><span class="s4">2</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s0">return </span><span class="s1">_receiver_connected</span>

    <span class="s0">if </span><span class="s1">name </span><span class="s2">== </span><span class="s3">&quot;WeakNamespace&quot;</span><span class="s2">:</span>
        <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span>
            <span class="s3">&quot;'WeakNamespace' is deprecated and will be removed in Blinker 1.9.&quot;</span>
            <span class="s3">&quot; Use 'Namespace' instead.&quot;</span><span class="s2">,</span>
            <span class="s1">DeprecationWarning</span><span class="s2">,</span>
            <span class="s1">stacklevel</span><span class="s2">=</span><span class="s4">2</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s0">return </span><span class="s1">_WeakNamespace</span>

    <span class="s0">raise </span><span class="s1">AttributeError</span><span class="s2">(</span><span class="s1">name</span><span class="s2">)</span>
</pre>
</body>
</html>