<html>
<head>
<title>cmd.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #5f826b; font-style: italic;}
.s6 { color: #2aacb8;}
.s7 { color: #a5c261;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
cmd.py</font>
</center></td></tr></table>
<pre><span class="s0"># Copyright (C) 2008, 2009 Michael Trier (mtrier@gmail.com) and contributors</span>
<span class="s0">#</span>
<span class="s0"># This module is part of GitPython and is released under the</span>
<span class="s0"># 3-Clause BSD License: https://opensource.org/license/bsd-3-clause/</span>

<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>

<span class="s1">__all__ </span><span class="s3">= [</span><span class="s4">&quot;GitMeta&quot;</span><span class="s3">, </span><span class="s4">&quot;Git&quot;</span><span class="s3">]</span>

<span class="s2">import </span><span class="s1">contextlib</span>
<span class="s2">import </span><span class="s1">io</span>
<span class="s2">import </span><span class="s1">itertools</span>
<span class="s2">import </span><span class="s1">logging</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">import </span><span class="s1">signal</span>
<span class="s2">import </span><span class="s1">subprocess</span>
<span class="s2">from </span><span class="s1">subprocess </span><span class="s2">import </span><span class="s1">DEVNULL</span><span class="s3">, </span><span class="s1">PIPE</span><span class="s3">, </span><span class="s1">Popen</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">from </span><span class="s1">textwrap </span><span class="s2">import </span><span class="s1">dedent</span>
<span class="s2">import </span><span class="s1">threading</span>
<span class="s2">import </span><span class="s1">warnings</span>

<span class="s2">from </span><span class="s1">git</span><span class="s3">.</span><span class="s1">compat </span><span class="s2">import </span><span class="s1">defenc</span><span class="s3">, </span><span class="s1">force_bytes</span><span class="s3">, </span><span class="s1">safe_decode</span>
<span class="s2">from </span><span class="s1">git</span><span class="s3">.</span><span class="s1">exc </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">CommandError</span><span class="s3">,</span>
    <span class="s1">GitCommandError</span><span class="s3">,</span>
    <span class="s1">GitCommandNotFound</span><span class="s3">,</span>
    <span class="s1">UnsafeOptionError</span><span class="s3">,</span>
    <span class="s1">UnsafeProtocolError</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">from </span><span class="s1">git</span><span class="s3">.</span><span class="s1">util </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">cygpath</span><span class="s3">,</span>
    <span class="s1">expand_path</span><span class="s3">,</span>
    <span class="s1">is_cygwin_git</span><span class="s3">,</span>
    <span class="s1">patch_env</span><span class="s3">,</span>
    <span class="s1">remove_password_if_present</span><span class="s3">,</span>
    <span class="s1">stream_copy</span><span class="s3">,</span>
<span class="s3">)</span>

<span class="s0"># typing ---------------------------------------------------------------------------</span>

<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">Any</span><span class="s3">,</span>
    <span class="s1">AnyStr</span><span class="s3">,</span>
    <span class="s1">BinaryIO</span><span class="s3">,</span>
    <span class="s1">Callable</span><span class="s3">,</span>
    <span class="s1">Dict</span><span class="s3">,</span>
    <span class="s1">IO</span><span class="s3">,</span>
    <span class="s1">Iterator</span><span class="s3">,</span>
    <span class="s1">List</span><span class="s3">,</span>
    <span class="s1">Mapping</span><span class="s3">,</span>
    <span class="s1">Optional</span><span class="s3">,</span>
    <span class="s1">Sequence</span><span class="s3">,</span>
    <span class="s1">TYPE_CHECKING</span><span class="s3">,</span>
    <span class="s1">TextIO</span><span class="s3">,</span>
    <span class="s1">Tuple</span><span class="s3">,</span>
    <span class="s1">Union</span><span class="s3">,</span>
    <span class="s1">cast</span><span class="s3">,</span>
    <span class="s1">overload</span><span class="s3">,</span>
<span class="s3">)</span>

<span class="s2">from </span><span class="s1">git</span><span class="s3">.</span><span class="s1">types </span><span class="s2">import </span><span class="s1">Literal</span><span class="s3">, </span><span class="s1">PathLike</span><span class="s3">, </span><span class="s1">TBD</span>

<span class="s2">if </span><span class="s1">TYPE_CHECKING</span><span class="s3">:</span>
    <span class="s2">from </span><span class="s1">git</span><span class="s3">.</span><span class="s1">diff </span><span class="s2">import </span><span class="s1">DiffIndex</span>
    <span class="s2">from </span><span class="s1">git</span><span class="s3">.</span><span class="s1">repo</span><span class="s3">.</span><span class="s1">base </span><span class="s2">import </span><span class="s1">Repo</span>

<span class="s0"># ---------------------------------------------------------------------------------</span>

<span class="s1">execute_kwargs </span><span class="s3">= {</span>
    <span class="s4">&quot;istream&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;with_extended_output&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;with_exceptions&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;as_process&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;output_stream&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;stdout_as_string&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;kill_after_timeout&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;with_stdout&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;universal_newlines&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;shell&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;env&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;max_chunk_size&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;strip_newline_in_stdout&quot;</span><span class="s3">,</span>
<span class="s3">}</span>

<span class="s1">_logger </span><span class="s3">= </span><span class="s1">logging</span><span class="s3">.</span><span class="s1">getLogger</span><span class="s3">(</span><span class="s1">__name__</span><span class="s3">)</span>


<span class="s0"># ==============================================================================</span>
<span class="s0">## @name Utilities</span>
<span class="s0"># ------------------------------------------------------------------------------</span>
<span class="s0"># Documentation</span>
<span class="s0">## @{</span>


<span class="s2">def </span><span class="s1">handle_process_output</span><span class="s3">(</span>
    <span class="s1">process</span><span class="s3">: </span><span class="s4">&quot;Git.AutoInterrupt&quot; </span><span class="s3">| </span><span class="s1">Popen</span><span class="s3">,</span>
    <span class="s1">stdout_handler</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span>
        <span class="s2">None</span><span class="s3">,</span>
        <span class="s1">Callable</span><span class="s3">[[</span><span class="s1">AnyStr</span><span class="s3">], </span><span class="s2">None</span><span class="s3">],</span>
        <span class="s1">Callable</span><span class="s3">[[</span><span class="s1">List</span><span class="s3">[</span><span class="s1">AnyStr</span><span class="s3">]], </span><span class="s2">None</span><span class="s3">],</span>
        <span class="s1">Callable</span><span class="s3">[[</span><span class="s1">bytes</span><span class="s3">, </span><span class="s4">&quot;Repo&quot;</span><span class="s3">, </span><span class="s4">&quot;DiffIndex&quot;</span><span class="s3">], </span><span class="s2">None</span><span class="s3">],</span>
    <span class="s3">],</span>
    <span class="s1">stderr_handler</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s2">None</span><span class="s3">, </span><span class="s1">Callable</span><span class="s3">[[</span><span class="s1">AnyStr</span><span class="s3">], </span><span class="s2">None</span><span class="s3">], </span><span class="s1">Callable</span><span class="s3">[[</span><span class="s1">List</span><span class="s3">[</span><span class="s1">AnyStr</span><span class="s3">]], </span><span class="s2">None</span><span class="s3">]],</span>
    <span class="s1">finalizer</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s2">None</span><span class="s3">, </span><span class="s1">Callable</span><span class="s3">[[</span><span class="s1">Union</span><span class="s3">[</span><span class="s1">Popen</span><span class="s3">, </span><span class="s4">&quot;Git.AutoInterrupt&quot;</span><span class="s3">]], </span><span class="s2">None</span><span class="s3">]] = </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">decode_streams</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">,</span>
    <span class="s1">kill_after_timeout</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s2">None</span><span class="s3">, </span><span class="s1">float</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
    <span class="s5">R&quot;&quot;&quot;Register for notifications to learn that process output is ready to read, and 
    dispatch lines to the respective line handlers. 
 
    This function returns once the finalizer returns. 
 
    :param process: 
        :class:`subprocess.Popen` instance. 
 
    :param stdout_handler: 
        f(stdout_line_string), or ``None``. 
 
    :param stderr_handler: 
        f(stderr_line_string), or ``None``. 
 
    :param finalizer: 
        f(proc) - wait for proc to finish. 
 
    :param decode_streams: 
        Assume stdout/stderr streams are binary and decode them before pushing their 
        contents to handlers. 
 
        This defaults to ``True``. Set it to ``False`` if: 
 
        - ``universal_newlines == True``, as then streams are in text mode, or 
        - decoding must happen later, such as for :class:`~git.diff.Diff`\s. 
 
    :param kill_after_timeout: 
        :class:`float` or ``None``, Default = ``None`` 
 
        To specify a timeout in seconds for the git command, after which the process 
        should be killed. 
    &quot;&quot;&quot;</span>

    <span class="s0"># Use 2 &quot;pump&quot; threads and wait for both to finish.</span>
    <span class="s2">def </span><span class="s1">pump_stream</span><span class="s3">(</span>
        <span class="s1">cmdline</span><span class="s3">: </span><span class="s1">List</span><span class="s3">[</span><span class="s1">str</span><span class="s3">],</span>
        <span class="s1">name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">,</span>
        <span class="s1">stream</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">BinaryIO</span><span class="s3">, </span><span class="s1">TextIO</span><span class="s3">],</span>
        <span class="s1">is_decode</span><span class="s3">: </span><span class="s1">bool</span><span class="s3">,</span>
        <span class="s1">handler</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s2">None</span><span class="s3">, </span><span class="s1">Callable</span><span class="s3">[[</span><span class="s1">Union</span><span class="s3">[</span><span class="s1">bytes</span><span class="s3">, </span><span class="s1">str</span><span class="s3">]], </span><span class="s2">None</span><span class="s3">]],</span>
    <span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s2">for </span><span class="s1">line </span><span class="s2">in </span><span class="s1">stream</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">handler</span><span class="s3">:</span>
                    <span class="s2">if </span><span class="s1">is_decode</span><span class="s3">:</span>
                        <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">line</span><span class="s3">, </span><span class="s1">bytes</span><span class="s3">)</span>
                        <span class="s1">line_str </span><span class="s3">= </span><span class="s1">line</span><span class="s3">.</span><span class="s1">decode</span><span class="s3">(</span><span class="s1">defenc</span><span class="s3">)</span>
                        <span class="s1">handler</span><span class="s3">(</span><span class="s1">line_str</span><span class="s3">)</span>
                    <span class="s2">else</span><span class="s3">:</span>
                        <span class="s1">handler</span><span class="s3">(</span><span class="s1">line</span><span class="s3">)</span>

        <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">ex</span><span class="s3">:</span>
            <span class="s1">_logger</span><span class="s3">.</span><span class="s1">error</span><span class="s3">(</span><span class="s4">f&quot;Pumping </span><span class="s2">{</span><span class="s1">name</span><span class="s2">!r} </span><span class="s4">of cmd(</span><span class="s2">{</span><span class="s1">remove_password_if_present</span><span class="s3">(</span><span class="s1">cmdline</span><span class="s3">)</span><span class="s2">}</span><span class="s4">) failed due to: </span><span class="s2">{</span><span class="s1">ex</span><span class="s2">!r}</span><span class="s4">&quot;</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s4">&quot;I/O operation on closed file&quot; </span><span class="s2">not in </span><span class="s1">str</span><span class="s3">(</span><span class="s1">ex</span><span class="s3">):</span>
                <span class="s0"># Only reraise if the error was not due to the stream closing.</span>
                <span class="s2">raise </span><span class="s1">CommandError</span><span class="s3">([</span><span class="s4">f&quot;&lt;</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s4">-pump&gt;&quot;</span><span class="s3">] + </span><span class="s1">remove_password_if_present</span><span class="s3">(</span><span class="s1">cmdline</span><span class="s3">), </span><span class="s1">ex</span><span class="s3">) </span><span class="s2">from </span><span class="s1">ex</span>
        <span class="s2">finally</span><span class="s3">:</span>
            <span class="s1">stream</span><span class="s3">.</span><span class="s1">close</span><span class="s3">()</span>

    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">process</span><span class="s3">, </span><span class="s4">&quot;proc&quot;</span><span class="s3">):</span>
        <span class="s1">process </span><span class="s3">= </span><span class="s1">cast</span><span class="s3">(</span><span class="s4">&quot;Git.AutoInterrupt&quot;</span><span class="s3">, </span><span class="s1">process</span><span class="s3">)</span>
        <span class="s1">cmdline</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s1">Tuple</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, ...] | </span><span class="s1">List</span><span class="s3">[</span><span class="s1">str</span><span class="s3">] = </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">process</span><span class="s3">.</span><span class="s1">proc</span><span class="s3">, </span><span class="s4">&quot;args&quot;</span><span class="s3">, </span><span class="s4">&quot;&quot;</span><span class="s3">)</span>
        <span class="s1">p_stdout </span><span class="s3">= </span><span class="s1">process</span><span class="s3">.</span><span class="s1">proc</span><span class="s3">.</span><span class="s1">stdout </span><span class="s2">if </span><span class="s1">process</span><span class="s3">.</span><span class="s1">proc </span><span class="s2">else None</span>
        <span class="s1">p_stderr </span><span class="s3">= </span><span class="s1">process</span><span class="s3">.</span><span class="s1">proc</span><span class="s3">.</span><span class="s1">stderr </span><span class="s2">if </span><span class="s1">process</span><span class="s3">.</span><span class="s1">proc </span><span class="s2">else None</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">process </span><span class="s3">= </span><span class="s1">cast</span><span class="s3">(</span><span class="s1">Popen</span><span class="s3">, </span><span class="s1">process</span><span class="s3">)  </span><span class="s0"># type: ignore[redundant-cast]</span>
        <span class="s1">cmdline </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">process</span><span class="s3">, </span><span class="s4">&quot;args&quot;</span><span class="s3">, </span><span class="s4">&quot;&quot;</span><span class="s3">)</span>
        <span class="s1">p_stdout </span><span class="s3">= </span><span class="s1">process</span><span class="s3">.</span><span class="s1">stdout</span>
        <span class="s1">p_stderr </span><span class="s3">= </span><span class="s1">process</span><span class="s3">.</span><span class="s1">stderr</span>

    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">cmdline</span><span class="s3">, (</span><span class="s1">tuple</span><span class="s3">, </span><span class="s1">list</span><span class="s3">)):</span>
        <span class="s1">cmdline </span><span class="s3">= </span><span class="s1">cmdline</span><span class="s3">.</span><span class="s1">split</span><span class="s3">()</span>

    <span class="s1">pumps</span><span class="s3">: </span><span class="s1">List</span><span class="s3">[</span><span class="s1">Tuple</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">IO</span><span class="s3">, </span><span class="s1">Callable</span><span class="s3">[..., </span><span class="s2">None</span><span class="s3">] | </span><span class="s2">None</span><span class="s3">]] = []</span>
    <span class="s2">if </span><span class="s1">p_stdout</span><span class="s3">:</span>
        <span class="s1">pumps</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s4">&quot;stdout&quot;</span><span class="s3">, </span><span class="s1">p_stdout</span><span class="s3">, </span><span class="s1">stdout_handler</span><span class="s3">))</span>
    <span class="s2">if </span><span class="s1">p_stderr</span><span class="s3">:</span>
        <span class="s1">pumps</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s4">&quot;stderr&quot;</span><span class="s3">, </span><span class="s1">p_stderr</span><span class="s3">, </span><span class="s1">stderr_handler</span><span class="s3">))</span>

    <span class="s1">threads</span><span class="s3">: </span><span class="s1">List</span><span class="s3">[</span><span class="s1">threading</span><span class="s3">.</span><span class="s1">Thread</span><span class="s3">] = []</span>

    <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">stream</span><span class="s3">, </span><span class="s1">handler </span><span class="s2">in </span><span class="s1">pumps</span><span class="s3">:</span>
        <span class="s1">t </span><span class="s3">= </span><span class="s1">threading</span><span class="s3">.</span><span class="s1">Thread</span><span class="s3">(</span><span class="s1">target</span><span class="s3">=</span><span class="s1">pump_stream</span><span class="s3">, </span><span class="s1">args</span><span class="s3">=(</span><span class="s1">cmdline</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">stream</span><span class="s3">, </span><span class="s1">decode_streams</span><span class="s3">, </span><span class="s1">handler</span><span class="s3">))</span>
        <span class="s1">t</span><span class="s3">.</span><span class="s1">daemon </span><span class="s3">= </span><span class="s2">True</span>
        <span class="s1">t</span><span class="s3">.</span><span class="s1">start</span><span class="s3">()</span>
        <span class="s1">threads</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">t</span><span class="s3">)</span>

    <span class="s0"># FIXME: Why join? Will block if stdin needs feeding...</span>
    <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">threads</span><span class="s3">:</span>
        <span class="s1">t</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">timeout</span><span class="s3">=</span><span class="s1">kill_after_timeout</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">t</span><span class="s3">.</span><span class="s1">is_alive</span><span class="s3">():</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">process</span><span class="s3">, </span><span class="s1">Git</span><span class="s3">.</span><span class="s1">AutoInterrupt</span><span class="s3">):</span>
                <span class="s1">process</span><span class="s3">.</span><span class="s1">_terminate</span><span class="s3">()</span>
            <span class="s2">else</span><span class="s3">:  </span><span class="s0"># Don't want to deal with the other case.</span>
                <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span>
                    <span class="s4">&quot;Thread join() timed out in cmd.handle_process_output().&quot;</span>
                    <span class="s4">f&quot; kill_after_timeout=</span><span class="s2">{</span><span class="s1">kill_after_timeout</span><span class="s2">} </span><span class="s4">seconds&quot;</span>
                <span class="s3">)</span>
            <span class="s2">if </span><span class="s1">stderr_handler</span><span class="s3">:</span>
                <span class="s1">error_str</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">bytes</span><span class="s3">] = (</span>
                    <span class="s4">&quot;error: process killed because it timed out.&quot; f&quot; kill_after_timeout=</span><span class="s2">{</span><span class="s1">kill_after_timeout</span><span class="s2">} </span><span class="s4">seconds&quot;</span>
                <span class="s3">)</span>
                <span class="s2">if not </span><span class="s1">decode_streams </span><span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">p_stderr</span><span class="s3">, </span><span class="s1">BinaryIO</span><span class="s3">):</span>
                    <span class="s0"># Assume stderr_handler needs binary input.</span>
                    <span class="s1">error_str </span><span class="s3">= </span><span class="s1">cast</span><span class="s3">(</span><span class="s1">str</span><span class="s3">, </span><span class="s1">error_str</span><span class="s3">)</span>
                    <span class="s1">error_str </span><span class="s3">= </span><span class="s1">error_str</span><span class="s3">.</span><span class="s1">encode</span><span class="s3">()</span>
                <span class="s0"># We ignore typing on the next line because mypy does not like the way</span>
                <span class="s0"># we inferred that stderr takes str or bytes.</span>
                <span class="s1">stderr_handler</span><span class="s3">(</span><span class="s1">error_str</span><span class="s3">)  </span><span class="s0"># type: ignore[arg-type]</span>

    <span class="s2">if </span><span class="s1">finalizer</span><span class="s3">:</span>
        <span class="s1">finalizer</span><span class="s3">(</span><span class="s1">process</span><span class="s3">)</span>


<span class="s1">safer_popen</span><span class="s3">: </span><span class="s1">Callable</span><span class="s3">[..., </span><span class="s1">Popen</span><span class="s3">]</span>

<span class="s2">if </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">platform </span><span class="s3">== </span><span class="s4">&quot;win32&quot;</span><span class="s3">:</span>

    <span class="s2">def </span><span class="s1">_safer_popen_windows</span><span class="s3">(</span>
        <span class="s1">command</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Sequence</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">]],</span>
        <span class="s3">*,</span>
        <span class="s1">shell</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">env</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Mapping</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">str</span><span class="s3">]] = </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s3">**</span><span class="s1">kwargs</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; Popen</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Call :class:`subprocess.Popen` on Windows but don't include a CWD in the 
        search. 
 
        This avoids an untrusted search path condition where a file like ``git.exe`` in 
        a malicious repository would be run when GitPython operates on the repository. 
        The process using GitPython may have an untrusted repository's working tree as 
        its current working directory. Some operations may temporarily change to that 
        directory before running a subprocess. In addition, while by default GitPython 
        does not run external commands with a shell, it can be made to do so, in which 
        case the CWD of the subprocess, which GitPython usually sets to a repository 
        working tree, can itself be searched automatically by the shell. This wrapper 
        covers all those cases. 
 
        :note: 
            This currently works by setting the 
            :envvar:`NoDefaultCurrentDirectoryInExePath` environment variable during 
            subprocess creation. It also takes care of passing Windows-specific process 
            creation flags, but that is unrelated to path search. 
 
        :note: 
            The current implementation contains a race condition on :attr:`os.environ`. 
            GitPython isn't thread-safe, but a program using it on one thread should 
            ideally be able to mutate :attr:`os.environ` on another, without 
            unpredictable results. See comments in: 
            https://github.com/gitpython-developers/GitPython/pull/1650 
        &quot;&quot;&quot;</span>
        <span class="s0"># CREATE_NEW_PROCESS_GROUP is needed for some ways of killing it afterwards.</span>
        <span class="s0"># https://docs.python.org/3/library/subprocess.html#subprocess.Popen.send_signal</span>
        <span class="s0"># https://docs.python.org/3/library/subprocess.html#subprocess.CREATE_NEW_PROCESS_GROUP</span>
        <span class="s1">creationflags </span><span class="s3">= </span><span class="s1">subprocess</span><span class="s3">.</span><span class="s1">CREATE_NO_WINDOW </span><span class="s3">| </span><span class="s1">subprocess</span><span class="s3">.</span><span class="s1">CREATE_NEW_PROCESS_GROUP</span>

        <span class="s0"># When using a shell, the shell is the direct subprocess, so the variable must</span>
        <span class="s0"># be set in its environment, to affect its search behavior.</span>
        <span class="s2">if </span><span class="s1">shell</span><span class="s3">:</span>
            <span class="s0"># The original may be immutable, or the caller may reuse it. Mutate a copy.</span>
            <span class="s1">env </span><span class="s3">= {} </span><span class="s2">if </span><span class="s1">env </span><span class="s2">is None else </span><span class="s1">dict</span><span class="s3">(</span><span class="s1">env</span><span class="s3">)</span>
            <span class="s1">env</span><span class="s3">[</span><span class="s4">&quot;NoDefaultCurrentDirectoryInExePath&quot;</span><span class="s3">] = </span><span class="s4">&quot;1&quot;  </span><span class="s0"># The &quot;1&quot; can be an value.</span>

        <span class="s0"># When not using a shell, the current process does the search in a</span>
        <span class="s0"># CreateProcessW API call, so the variable must be set in our environment. With</span>
        <span class="s0"># a shell, that's unnecessary if https://github.com/python/cpython/issues/101283</span>
        <span class="s0"># is patched. In Python versions where it is unpatched, and in the rare case the</span>
        <span class="s0"># ComSpec environment variable is unset, the search for the shell itself is</span>
        <span class="s0"># unsafe. Setting NoDefaultCurrentDirectoryInExePath in all cases, as done here,</span>
        <span class="s0"># is simpler and protects against that. (As above, the &quot;1&quot; can be any value.)</span>
        <span class="s2">with </span><span class="s1">patch_env</span><span class="s3">(</span><span class="s4">&quot;NoDefaultCurrentDirectoryInExePath&quot;</span><span class="s3">, </span><span class="s4">&quot;1&quot;</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">Popen</span><span class="s3">(</span>
                <span class="s1">command</span><span class="s3">,</span>
                <span class="s1">shell</span><span class="s3">=</span><span class="s1">shell</span><span class="s3">,</span>
                <span class="s1">env</span><span class="s3">=</span><span class="s1">env</span><span class="s3">,</span>
                <span class="s1">creationflags</span><span class="s3">=</span><span class="s1">creationflags</span><span class="s3">,</span>
                <span class="s3">**</span><span class="s1">kwargs</span><span class="s3">,</span>
            <span class="s3">)</span>

    <span class="s1">safer_popen </span><span class="s3">= </span><span class="s1">_safer_popen_windows</span>
<span class="s2">else</span><span class="s3">:</span>
    <span class="s1">safer_popen </span><span class="s3">= </span><span class="s1">Popen</span>


<span class="s2">def </span><span class="s1">dashify</span><span class="s3">(</span><span class="s1">string</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; str</span><span class="s3">:</span>
    <span class="s2">return </span><span class="s1">string</span><span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s4">&quot;_&quot;</span><span class="s3">, </span><span class="s4">&quot;-&quot;</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">slots_to_dict</span><span class="s3">(</span><span class="s1">self</span><span class="s3">: </span><span class="s4">&quot;Git&quot;</span><span class="s3">, </span><span class="s1">exclude</span><span class="s3">: </span><span class="s1">Sequence</span><span class="s3">[</span><span class="s1">str</span><span class="s3">] = ()) </span><span class="s1">-&gt; Dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]:</span>
    <span class="s2">return </span><span class="s3">{</span><span class="s1">s</span><span class="s3">: </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">s</span><span class="s3">) </span><span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__slots__ </span><span class="s2">if </span><span class="s1">s </span><span class="s2">not in </span><span class="s1">exclude</span><span class="s3">}</span>


<span class="s2">def </span><span class="s1">dict_to_slots_and__excluded_are_none</span><span class="s3">(</span><span class="s1">self</span><span class="s3">: </span><span class="s1">object</span><span class="s3">, </span><span class="s1">d</span><span class="s3">: </span><span class="s1">Mapping</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">], </span><span class="s1">excluded</span><span class="s3">: </span><span class="s1">Sequence</span><span class="s3">[</span><span class="s1">str</span><span class="s3">] = ()) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
    <span class="s2">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">d</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s1">setattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">excluded</span><span class="s3">:</span>
        <span class="s1">setattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>


<span class="s0">## -- End Utilities -- @}</span>

<span class="s1">_USE_SHELL_DEFAULT_MESSAGE </span><span class="s3">= (</span>
    <span class="s4">&quot;Git.USE_SHELL is deprecated, because only its default value of False is safe. &quot;</span>
    <span class="s4">&quot;It will be removed in a future release.&quot;</span>
<span class="s3">)</span>

<span class="s1">_USE_SHELL_DANGER_MESSAGE </span><span class="s3">= (</span>
    <span class="s4">&quot;Setting Git.USE_SHELL to True is unsafe and insecure, as the effect of special &quot;</span>
    <span class="s4">&quot;shell syntax cannot usually be accounted for. This can result in a command &quot;</span>
    <span class="s4">&quot;injection vulnerability and arbitrary code execution. Git.USE_SHELL is deprecated &quot;</span>
    <span class="s4">&quot;and will be removed in a future release.&quot;</span>
<span class="s3">)</span>


<span class="s2">def </span><span class="s1">_warn_use_shell</span><span class="s3">(</span><span class="s1">extra_danger</span><span class="s3">: </span><span class="s1">bool</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
    <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
        <span class="s1">_USE_SHELL_DANGER_MESSAGE </span><span class="s2">if </span><span class="s1">extra_danger </span><span class="s2">else </span><span class="s1">_USE_SHELL_DEFAULT_MESSAGE</span><span class="s3">,</span>
        <span class="s1">DeprecationWarning</span><span class="s3">,</span>
        <span class="s1">stacklevel</span><span class="s3">=</span><span class="s6">3</span><span class="s3">,</span>
    <span class="s3">)</span>


<span class="s2">class </span><span class="s1">_GitMeta</span><span class="s3">(</span><span class="s1">type</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot;Metaclass for :class:`Git`. 
 
    This helps issue :class:`DeprecationWarning` if :attr:`Git.USE_SHELL` is used. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__getattribute</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; Any</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s3">== </span><span class="s4">&quot;USE_SHELL&quot;</span><span class="s3">:</span>
            <span class="s1">_warn_use_shell</span><span class="s3">(</span><span class="s2">False</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">super</span><span class="s3">().</span><span class="s1">__getattribute__</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__setattr</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">, </span><span class="s1">value</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; Any</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s3">== </span><span class="s4">&quot;USE_SHELL&quot;</span><span class="s3">:</span>
            <span class="s1">_warn_use_shell</span><span class="s3">(</span><span class="s1">value</span><span class="s3">)</span>
        <span class="s1">super</span><span class="s3">().</span><span class="s1">__setattr__</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>

    <span class="s2">if not </span><span class="s1">TYPE_CHECKING</span><span class="s3">:</span>
        <span class="s0"># To preserve static checking for undefined/misspelled attributes while letting</span>
        <span class="s0"># the methods' bodies be type-checked, these are defined as non-special methods,</span>
        <span class="s0"># then bound to special names out of view of static type checkers. (The original</span>
        <span class="s0"># names invoke name mangling (leading &quot;__&quot;) to avoid confusion in other scopes.)</span>
        <span class="s1">__getattribute__ </span><span class="s3">= </span><span class="s1">__getattribute</span>
        <span class="s1">__setattr__ </span><span class="s3">= </span><span class="s1">__setattr</span>


<span class="s1">GitMeta </span><span class="s3">= </span><span class="s1">_GitMeta</span>
<span class="s4">&quot;&quot;&quot;Alias of :class:`Git`'s metaclass, whether it is :class:`type` or a custom metaclass. 
 
Whether the :class:`Git` class has the default :class:`type` as its metaclass or uses a 
custom metaclass is not documented and may change at any time. This statically checkable 
metaclass alias is equivalent at runtime to ``type(Git)``. This should almost never be 
used. Code that benefits from it is likely to be remain brittle even if it is used. 
 
In view of the :class:`Git` class's intended use and :class:`Git` objects' dynamic 
callable attributes representing git subcommands, it rarely makes sense to inherit from 
:class:`Git` at all. Using :class:`Git` in multiple inheritance can be especially tricky 
to do correctly. Attempting uses of :class:`Git` where its metaclass is relevant, such 
as when a sibling class has an unrelated metaclass and a shared lower bound metaclass 
might have to be introduced to solve a metaclass conflict, is not recommended. 
 
:note: 
    The correct static type of the :class:`Git` class itself, and any subclasses, is 
    ``Type[Git]``. (This can be written as ``type[Git]`` in Python 3.9 later.) 
 
    :class:`GitMeta` should never be used in any annotation where ``Type[Git]`` is 
    intended or otherwise possible to use. This alias is truly only for very rare and 
    inherently precarious situations where it is necessary to deal with the metaclass 
    explicitly. 
&quot;&quot;&quot;</span>


<span class="s2">class </span><span class="s1">Git</span><span class="s3">(</span><span class="s1">metaclass</span><span class="s3">=</span><span class="s1">_GitMeta</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot;The Git class manages communication with the Git binary. 
 
    It provides a convenient interface to calling the Git binary, such as in:: 
 
     g = Git( git_dir ) 
     g.init()                   # calls 'git init' program 
     rval = g.ls_files()        # calls 'git ls-files' program 
 
    Debugging: 
 
    * Set the :envvar:`GIT_PYTHON_TRACE` environment variable to print each invocation 
      of the command to stdout. 
    * Set its value to ``full`` to see details about the returned values. 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ </span><span class="s3">= (</span>
        <span class="s4">&quot;_working_dir&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;cat_file_all&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;cat_file_header&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;_version_info&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;_version_info_token&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;_git_options&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;_persistent_git_options&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;_environment&quot;</span><span class="s3">,</span>
    <span class="s3">)</span>

    <span class="s1">_excluded_ </span><span class="s3">= (</span>
        <span class="s4">&quot;cat_file_all&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;cat_file_header&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;_version_info&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;_version_info_token&quot;</span><span class="s3">,</span>
    <span class="s3">)</span>

    <span class="s1">re_unsafe_protocol </span><span class="s3">= </span><span class="s1">re</span><span class="s3">.</span><span class="s1">compile</span><span class="s3">(</span><span class="s4">r&quot;(.+)::.+&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__getstate__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; Dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]:</span>
        <span class="s2">return </span><span class="s1">slots_to_dict</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">exclude</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_excluded_</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__setstate__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">d</span><span class="s3">: </span><span class="s1">Dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s1">dict_to_slots_and__excluded_are_none</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">d</span><span class="s3">, </span><span class="s1">excluded</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_excluded_</span><span class="s3">)</span>

    <span class="s0"># CONFIGURATION</span>

    <span class="s1">git_exec_name </span><span class="s3">= </span><span class="s4">&quot;git&quot;</span>
    <span class="s4">&quot;&quot;&quot;Default git command that should work on Linux, Windows, and other systems.&quot;&quot;&quot;</span>

    <span class="s1">GIT_PYTHON_TRACE </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">environ</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">&quot;GIT_PYTHON_TRACE&quot;</span><span class="s3">, </span><span class="s2">False</span><span class="s3">)</span>
    <span class="s4">&quot;&quot;&quot;Enables debugging of GitPython's git commands.&quot;&quot;&quot;</span>

    <span class="s1">USE_SHELL</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span>
    <span class="s4">&quot;&quot;&quot;Deprecated. If set to ``True``, a shell will be used when executing git commands. 
 
    Code that uses ``USE_SHELL = True`` or that passes ``shell=True`` to any GitPython 
    functions should be updated to use the default value of ``False`` instead. ``True`` 
    is unsafe unless the effect of syntax treated specially by the shell is fully 
    considered and accounted for, which is not possible under most circumstances. As 
    detailed below, it is also no longer needed, even where it had been in the past. 
 
    It is in many if not most cases a command injection vulnerability for an application 
    to set :attr:`USE_SHELL` to ``True``. Any attacker who can cause a specially crafted 
    fragment of text to make its way into any part of any argument to any git command 
    (including paths, branch names, etc.) can cause the shell to read and write 
    arbitrary files and execute arbitrary commands. Innocent input may also accidentally 
    contain special shell syntax, leading to inadvertent malfunctions. 
 
    In addition, how a value of ``True`` interacts with some aspects of GitPython's 
    operation is not precisely specified and may change without warning, even before 
    GitPython 4.0.0 when :attr:`USE_SHELL` may be removed. This includes: 
 
    * Whether or how GitPython automatically customizes the shell environment. 
 
    * Whether, outside of Windows (where :class:`subprocess.Popen` supports lists of 
      separate arguments even when ``shell=True``), this can be used with any GitPython 
      functionality other than direct calls to the :meth:`execute` method. 
 
    * Whether any GitPython feature that runs git commands ever attempts to partially 
      sanitize data a shell may treat specially. Currently this is not done. 
 
    Prior to GitPython 2.0.8, this had a narrow purpose in suppressing console windows 
    in graphical Windows applications. In 2.0.8 and higher, it provides no benefit, as 
    GitPython solves that problem more robustly and safely by using the 
    ``CREATE_NO_WINDOW`` process creation flag on Windows. 
 
    Because Windows path search differs subtly based on whether a shell is used, in rare 
    cases changing this from ``True`` to ``False`` may keep an unusual git &quot;executable&quot;, 
    such as a batch file, from being found. To fix this, set the command name or full 
    path in the :envvar:`GIT_PYTHON_GIT_EXECUTABLE` environment variable or pass the 
    full path to :func:`git.refresh` (or invoke the script using a ``.exe`` shim). 
 
    Further reading: 
 
    * :meth:`Git.execute` (on the ``shell`` parameter). 
    * https://github.com/gitpython-developers/GitPython/commit/0d9390866f9ce42870d3116094cd49e0019a970a 
    * https://learn.microsoft.com/en-us/windows/win32/procthread/process-creation-flags 
    * https://github.com/python/cpython/issues/91558#issuecomment-1100942950 
    * https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessw 
    &quot;&quot;&quot;</span>

    <span class="s1">_git_exec_env_var </span><span class="s3">= </span><span class="s4">&quot;GIT_PYTHON_GIT_EXECUTABLE&quot;</span>
    <span class="s1">_refresh_env_var </span><span class="s3">= </span><span class="s4">&quot;GIT_PYTHON_REFRESH&quot;</span>

    <span class="s1">GIT_PYTHON_GIT_EXECUTABLE </span><span class="s3">= </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;Provide the full path to the git executable. Otherwise it assumes git is in the 
    executable search path. 
 
    :note: 
        The git executable is actually found during the refresh step in the top level 
        ``__init__``. It can also be changed by explicitly calling :func:`git.refresh`. 
    &quot;&quot;&quot;</span>

    <span class="s1">_refresh_token </span><span class="s3">= </span><span class="s1">object</span><span class="s3">()  </span><span class="s0"># Since None would match an initial _version_info_token.</span>

    <span class="s3">@</span><span class="s1">classmethod</span>
    <span class="s2">def </span><span class="s1">refresh</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">path</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s2">None</span><span class="s3">, </span><span class="s1">PathLike</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Update information about the git executable :class:`Git` objects will use. 
 
        Called by the :func:`git.refresh` function in the top level ``__init__``. 
 
        :param path: 
            Optional path to the git executable. If not absolute, it is resolved 
            immediately, relative to the current directory. (See note below.) 
 
        :note: 
            The top-level :func:`git.refresh` should be preferred because it calls this 
            method and may also update other state accordingly. 
 
        :note: 
            There are three different ways to specify the command that refreshing causes 
            to be used for git: 
 
            1. Pass no `path` argument and do not set the 
               :envvar:`GIT_PYTHON_GIT_EXECUTABLE` environment variable. The command 
               name ``git`` is used. It is looked up in a path search by the system, in 
               each command run (roughly similar to how git is found when running 
               ``git`` commands manually). This is usually the desired behavior. 
 
            2. Pass no `path` argument but set the :envvar:`GIT_PYTHON_GIT_EXECUTABLE` 
               environment variable. The command given as the value of that variable is 
               used. This may be a simple command or an arbitrary path. It is looked up 
               in each command run. Setting :envvar:`GIT_PYTHON_GIT_EXECUTABLE` to 
               ``git`` has the same effect as not setting it. 
 
            3. Pass a `path` argument. This path, if not absolute, is immediately 
               resolved, relative to the current directory. This resolution occurs at 
               the time of the refresh. When git commands are run, they are run using 
               that previously resolved path. If a `path` argument is passed, the 
               :envvar:`GIT_PYTHON_GIT_EXECUTABLE` environment variable is not 
               consulted. 
 
        :note: 
            Refreshing always sets the :attr:`Git.GIT_PYTHON_GIT_EXECUTABLE` class 
            attribute, which can be read on the :class:`Git` class or any of its 
            instances to check what command is used to run git. This attribute should 
            not be confused with the related :envvar:`GIT_PYTHON_GIT_EXECUTABLE` 
            environment variable. The class attribute is set no matter how refreshing is 
            performed. 
        &quot;&quot;&quot;</span>
        <span class="s0"># Discern which path to refresh with.</span>
        <span class="s2">if </span><span class="s1">path </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">new_git </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">expanduser</span><span class="s3">(</span><span class="s1">path</span><span class="s3">)</span>
            <span class="s1">new_git </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">abspath</span><span class="s3">(</span><span class="s1">new_git</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">new_git </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">environ</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">.</span><span class="s1">_git_exec_env_var</span><span class="s3">, </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">git_exec_name</span><span class="s3">)</span>

        <span class="s0"># Keep track of the old and new git executable path.</span>
        <span class="s1">old_git </span><span class="s3">= </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">GIT_PYTHON_GIT_EXECUTABLE</span>
        <span class="s1">old_refresh_token </span><span class="s3">= </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">_refresh_token</span>
        <span class="s1">cls</span><span class="s3">.</span><span class="s1">GIT_PYTHON_GIT_EXECUTABLE </span><span class="s3">= </span><span class="s1">new_git</span>
        <span class="s1">cls</span><span class="s3">.</span><span class="s1">_refresh_token </span><span class="s3">= </span><span class="s1">object</span><span class="s3">()</span>

        <span class="s0"># Test if the new git executable path is valid. A GitCommandNotFound error is</span>
        <span class="s0"># raised by us. A PermissionError is raised if the git executable cannot be</span>
        <span class="s0"># executed for whatever reason.</span>
        <span class="s1">has_git </span><span class="s3">= </span><span class="s2">False</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">cls</span><span class="s3">().</span><span class="s1">version</span><span class="s3">()</span>
            <span class="s1">has_git </span><span class="s3">= </span><span class="s2">True</span>
        <span class="s2">except </span><span class="s3">(</span><span class="s1">GitCommandNotFound</span><span class="s3">, </span><span class="s1">PermissionError</span><span class="s3">):</span>
            <span class="s2">pass</span>

        <span class="s0"># Warn or raise exception if test failed.</span>
        <span class="s2">if not </span><span class="s1">has_git</span><span class="s3">:</span>
            <span class="s1">err </span><span class="s3">= (</span>
                <span class="s1">dedent</span><span class="s3">(</span>
                    <span class="s4">&quot;&quot;&quot;</span><span class="s2">\ 
                </span><span class="s4">Bad git executable. 
                The git executable must be specified in one of the following ways: 
                    - be included in your $PATH 
                    - be set via $%s 
                    - explicitly set via git.refresh(&lt;full-path-to-git-executable&gt;) 
                &quot;&quot;&quot;</span>
                <span class="s3">)</span>
                <span class="s3">% </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">_git_exec_env_var</span>
            <span class="s3">)</span>

            <span class="s0"># Revert to whatever the old_git was.</span>
            <span class="s1">cls</span><span class="s3">.</span><span class="s1">GIT_PYTHON_GIT_EXECUTABLE </span><span class="s3">= </span><span class="s1">old_git</span>
            <span class="s1">cls</span><span class="s3">.</span><span class="s1">_refresh_token </span><span class="s3">= </span><span class="s1">old_refresh_token</span>

            <span class="s2">if </span><span class="s1">old_git </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s0"># On the first refresh (when GIT_PYTHON_GIT_EXECUTABLE is None) we only</span>
                <span class="s0"># are quiet, warn, or error depending on the GIT_PYTHON_REFRESH value.</span>

                <span class="s0"># Determine what the user wants to happen during the initial refresh. We</span>
                <span class="s0"># expect GIT_PYTHON_REFRESH to either be unset or be one of the</span>
                <span class="s0"># following values:</span>
                <span class="s0">#</span>
                <span class="s0">#   0|q|quiet|s|silence|silent|n|none</span>
                <span class="s0">#   1|w|warn|warning|l|log</span>
                <span class="s0">#   2|r|raise|e|error|exception</span>

                <span class="s1">mode </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">environ</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">.</span><span class="s1">_refresh_env_var</span><span class="s3">, </span><span class="s4">&quot;raise&quot;</span><span class="s3">).</span><span class="s1">lower</span><span class="s3">()</span>

                <span class="s1">quiet </span><span class="s3">= [</span><span class="s4">&quot;quiet&quot;</span><span class="s3">, </span><span class="s4">&quot;q&quot;</span><span class="s3">, </span><span class="s4">&quot;silence&quot;</span><span class="s3">, </span><span class="s4">&quot;s&quot;</span><span class="s3">, </span><span class="s4">&quot;silent&quot;</span><span class="s3">, </span><span class="s4">&quot;none&quot;</span><span class="s3">, </span><span class="s4">&quot;n&quot;</span><span class="s3">, </span><span class="s4">&quot;0&quot;</span><span class="s3">]</span>
                <span class="s1">warn </span><span class="s3">= [</span><span class="s4">&quot;warn&quot;</span><span class="s3">, </span><span class="s4">&quot;w&quot;</span><span class="s3">, </span><span class="s4">&quot;warning&quot;</span><span class="s3">, </span><span class="s4">&quot;log&quot;</span><span class="s3">, </span><span class="s4">&quot;l&quot;</span><span class="s3">, </span><span class="s4">&quot;1&quot;</span><span class="s3">]</span>
                <span class="s1">error </span><span class="s3">= [</span><span class="s4">&quot;error&quot;</span><span class="s3">, </span><span class="s4">&quot;e&quot;</span><span class="s3">, </span><span class="s4">&quot;exception&quot;</span><span class="s3">, </span><span class="s4">&quot;raise&quot;</span><span class="s3">, </span><span class="s4">&quot;r&quot;</span><span class="s3">, </span><span class="s4">&quot;2&quot;</span><span class="s3">]</span>

                <span class="s2">if </span><span class="s1">mode </span><span class="s2">in </span><span class="s1">quiet</span><span class="s3">:</span>
                    <span class="s2">pass</span>
                <span class="s2">elif </span><span class="s1">mode </span><span class="s2">in </span><span class="s1">warn </span><span class="s2">or </span><span class="s1">mode </span><span class="s2">in </span><span class="s1">error</span><span class="s3">:</span>
                    <span class="s1">err </span><span class="s3">= </span><span class="s1">dedent</span><span class="s3">(</span>
                        <span class="s4">&quot;&quot;&quot;</span><span class="s2">\ 
                        </span><span class="s4">%s 
                        All git commands will error until this is rectified. 
 
                        This initial message can be silenced or aggravated in the future by setting the 
                        $%s environment variable. Use one of the following values: 
                            - %s: for no message or exception 
                            - %s: for a warning message (logging level CRITICAL, displayed by default) 
                            - %s: for a raised exception 
 
                        Example: 
                            export %s=%s 
                        &quot;&quot;&quot;</span>
                    <span class="s3">) % (</span>
                        <span class="s1">err</span><span class="s3">,</span>
                        <span class="s1">cls</span><span class="s3">.</span><span class="s1">_refresh_env_var</span><span class="s3">,</span>
                        <span class="s4">&quot;|&quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">quiet</span><span class="s3">),</span>
                        <span class="s4">&quot;|&quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">warn</span><span class="s3">),</span>
                        <span class="s4">&quot;|&quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">error</span><span class="s3">),</span>
                        <span class="s1">cls</span><span class="s3">.</span><span class="s1">_refresh_env_var</span><span class="s3">,</span>
                        <span class="s1">quiet</span><span class="s3">[</span><span class="s6">0</span><span class="s3">],</span>
                    <span class="s3">)</span>

                    <span class="s2">if </span><span class="s1">mode </span><span class="s2">in </span><span class="s1">warn</span><span class="s3">:</span>
                        <span class="s1">_logger</span><span class="s3">.</span><span class="s1">critical</span><span class="s3">(</span><span class="s1">err</span><span class="s3">)</span>
                    <span class="s2">else</span><span class="s3">:</span>
                        <span class="s2">raise </span><span class="s1">ImportError</span><span class="s3">(</span><span class="s1">err</span><span class="s3">)</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">err </span><span class="s3">= </span><span class="s1">dedent</span><span class="s3">(</span>
                        <span class="s4">&quot;&quot;&quot;</span><span class="s2">\ 
                        </span><span class="s4">%s environment variable has been set but it has been set with an invalid value. 
 
                        Use only the following values: 
                            - %s: for no message or exception 
                            - %s: for a warning message (logging level CRITICAL, displayed by default) 
                            - %s: for a raised exception 
                        &quot;&quot;&quot;</span>
                    <span class="s3">) % (</span>
                        <span class="s1">cls</span><span class="s3">.</span><span class="s1">_refresh_env_var</span><span class="s3">,</span>
                        <span class="s4">&quot;|&quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">quiet</span><span class="s3">),</span>
                        <span class="s4">&quot;|&quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">warn</span><span class="s3">),</span>
                        <span class="s4">&quot;|&quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">error</span><span class="s3">),</span>
                    <span class="s3">)</span>
                    <span class="s2">raise </span><span class="s1">ImportError</span><span class="s3">(</span><span class="s1">err</span><span class="s3">)</span>

                <span class="s0"># We get here if this was the initial refresh and the refresh mode was</span>
                <span class="s0"># not error. Go ahead and set the GIT_PYTHON_GIT_EXECUTABLE such that we</span>
                <span class="s0"># discern the difference between the first refresh at import time</span>
                <span class="s0"># and subsequent calls to git.refresh or this refresh method.</span>
                <span class="s1">cls</span><span class="s3">.</span><span class="s1">GIT_PYTHON_GIT_EXECUTABLE </span><span class="s3">= </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">git_exec_name</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s0"># After the first refresh (when GIT_PYTHON_GIT_EXECUTABLE is no longer</span>
                <span class="s0"># None) we raise an exception.</span>
                <span class="s2">raise </span><span class="s1">GitCommandNotFound</span><span class="s3">(</span><span class="s1">new_git</span><span class="s3">, </span><span class="s1">err</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">has_git</span>

    <span class="s3">@</span><span class="s1">classmethod</span>
    <span class="s2">def </span><span class="s1">is_cygwin</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">is_cygwin_git</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">.</span><span class="s1">GIT_PYTHON_GIT_EXECUTABLE</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s3">@</span><span class="s1">classmethod</span>
    <span class="s2">def </span><span class="s1">polish_url</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">url</span><span class="s3">: </span><span class="s1">str</span><span class="s3">, </span><span class="s1">is_cygwin</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s2">False</span><span class="s3">] = ...) </span><span class="s1">-&gt; str</span><span class="s3">: ...</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s3">@</span><span class="s1">classmethod</span>
    <span class="s2">def </span><span class="s1">polish_url</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">url</span><span class="s3">: </span><span class="s1">str</span><span class="s3">, </span><span class="s1">is_cygwin</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s2">None</span><span class="s3">, </span><span class="s1">bool</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">) </span><span class="s1">-&gt; str</span><span class="s3">: ...</span>

    <span class="s3">@</span><span class="s1">classmethod</span>
    <span class="s2">def </span><span class="s1">polish_url</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">url</span><span class="s3">: </span><span class="s1">str</span><span class="s3">, </span><span class="s1">is_cygwin</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s2">None</span><span class="s3">, </span><span class="s1">bool</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">) </span><span class="s1">-&gt; PathLike</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Remove any backslashes from URLs to be written in config files. 
 
        Windows might create config files containing paths with backslashes, but git 
        stops liking them as it will escape the backslashes. Hence we undo the escaping 
        just to be sure. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">is_cygwin </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">is_cygwin </span><span class="s3">= </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">is_cygwin</span><span class="s3">()</span>

        <span class="s2">if </span><span class="s1">is_cygwin</span><span class="s3">:</span>
            <span class="s1">url </span><span class="s3">= </span><span class="s1">cygpath</span><span class="s3">(</span><span class="s1">url</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">url </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">expandvars</span><span class="s3">(</span><span class="s1">url</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">url</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s4">&quot;~&quot;</span><span class="s3">):</span>
                <span class="s1">url </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">expanduser</span><span class="s3">(</span><span class="s1">url</span><span class="s3">)</span>
            <span class="s1">url </span><span class="s3">= </span><span class="s1">url</span><span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s4">&quot;</span><span class="s2">\\\\</span><span class="s4">&quot;</span><span class="s3">, </span><span class="s4">&quot;</span><span class="s2">\\</span><span class="s4">&quot;</span><span class="s3">).</span><span class="s1">replace</span><span class="s3">(</span><span class="s4">&quot;</span><span class="s2">\\</span><span class="s4">&quot;</span><span class="s3">, </span><span class="s4">&quot;/&quot;</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">url</span>

    <span class="s3">@</span><span class="s1">classmethod</span>
    <span class="s2">def </span><span class="s1">check_unsafe_protocols</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">url</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Check for unsafe protocols. 
 
        Apart from the usual protocols (http, git, ssh), Git allows &quot;remote helpers&quot; 
        that have the form ``&lt;transport&gt;::&lt;address&gt;``. One of these helpers (``ext::``) 
        can be used to invoke any arbitrary command. 
 
        See: 
 
        - https://git-scm.com/docs/gitremote-helpers 
        - https://git-scm.com/docs/git-remote-ext 
        &quot;&quot;&quot;</span>
        <span class="s1">match </span><span class="s3">= </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">re_unsafe_protocol</span><span class="s3">.</span><span class="s1">match</span><span class="s3">(</span><span class="s1">url</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">match</span><span class="s3">:</span>
            <span class="s1">protocol </span><span class="s3">= </span><span class="s1">match</span><span class="s3">.</span><span class="s1">group</span><span class="s3">(</span><span class="s6">1</span><span class="s3">)</span>
            <span class="s2">raise </span><span class="s1">UnsafeProtocolError</span><span class="s3">(</span>
                <span class="s4">f&quot;The `</span><span class="s2">{</span><span class="s1">protocol</span><span class="s2">}</span><span class="s4">::` protocol looks suspicious, use `allow_unsafe_protocols=True` to allow it.&quot;</span>
            <span class="s3">)</span>

    <span class="s3">@</span><span class="s1">classmethod</span>
    <span class="s2">def </span><span class="s1">check_unsafe_options</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">options</span><span class="s3">: </span><span class="s1">List</span><span class="s3">[</span><span class="s1">str</span><span class="s3">], </span><span class="s1">unsafe_options</span><span class="s3">: </span><span class="s1">List</span><span class="s3">[</span><span class="s1">str</span><span class="s3">]) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Check for unsafe options. 
 
        Some options that are passed to ``git &lt;command&gt;`` can be used to execute 
        arbitrary commands. These are blocked by default. 
        &quot;&quot;&quot;</span>
        <span class="s0"># Options can be of the form `foo`, `--foo bar`, or `--foo=bar`, so we need to</span>
        <span class="s0"># check if they start with &quot;--foo&quot; or if they are equal to &quot;foo&quot;.</span>
        <span class="s1">bare_unsafe_options </span><span class="s3">= [</span><span class="s1">option</span><span class="s3">.</span><span class="s1">lstrip</span><span class="s3">(</span><span class="s4">&quot;-&quot;</span><span class="s3">) </span><span class="s2">for </span><span class="s1">option </span><span class="s2">in </span><span class="s1">unsafe_options</span><span class="s3">]</span>
        <span class="s2">for </span><span class="s1">option </span><span class="s2">in </span><span class="s1">options</span><span class="s3">:</span>
            <span class="s2">for </span><span class="s1">unsafe_option</span><span class="s3">, </span><span class="s1">bare_option </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">unsafe_options</span><span class="s3">, </span><span class="s1">bare_unsafe_options</span><span class="s3">):</span>
                <span class="s2">if </span><span class="s1">option</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s1">unsafe_option</span><span class="s3">) </span><span class="s2">or </span><span class="s1">option </span><span class="s3">== </span><span class="s1">bare_option</span><span class="s3">:</span>
                    <span class="s2">raise </span><span class="s1">UnsafeOptionError</span><span class="s3">(</span>
                        <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">unsafe_option</span><span class="s2">} </span><span class="s4">is not allowed, use `allow_unsafe_options=True` to allow it.&quot;</span>
                    <span class="s3">)</span>

    <span class="s2">class </span><span class="s1">AutoInterrupt</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Process wrapper that terminates the wrapped process on finalization. 
 
        This kills/interrupts the stored process instance once this instance goes out of 
        scope. It is used to prevent processes piling up in case iterators stop reading. 
 
        All attributes are wired through to the contained process object. 
 
        The wait method is overridden to perform automatic status code checking and 
        possibly raise. 
        &quot;&quot;&quot;</span>

        <span class="s1">__slots__ </span><span class="s3">= (</span><span class="s4">&quot;proc&quot;</span><span class="s3">, </span><span class="s4">&quot;args&quot;</span><span class="s3">, </span><span class="s4">&quot;status&quot;</span><span class="s3">)</span>

        <span class="s0"># If this is non-zero it will override any status code during _terminate, used</span>
        <span class="s0"># to prevent race conditions in testing.</span>
        <span class="s1">_status_code_if_terminate</span><span class="s3">: </span><span class="s1">int </span><span class="s3">= </span><span class="s6">0</span>

        <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">proc</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s2">None</span><span class="s3">, </span><span class="s1">subprocess</span><span class="s3">.</span><span class="s1">Popen</span><span class="s3">], </span><span class="s1">args</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">proc </span><span class="s3">= </span><span class="s1">proc</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">args </span><span class="s3">= </span><span class="s1">args</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">status</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">int</span><span class="s3">, </span><span class="s2">None</span><span class="s3">] = </span><span class="s2">None</span>

        <span class="s2">def </span><span class="s1">_terminate</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
            <span class="s5">&quot;&quot;&quot;Terminate the underlying process.&quot;&quot;&quot;</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">proc </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s2">return</span>

            <span class="s1">proc </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">proc</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">proc </span><span class="s3">= </span><span class="s2">None</span>
            <span class="s2">if </span><span class="s1">proc</span><span class="s3">.</span><span class="s1">stdin</span><span class="s3">:</span>
                <span class="s1">proc</span><span class="s3">.</span><span class="s1">stdin</span><span class="s3">.</span><span class="s1">close</span><span class="s3">()</span>
            <span class="s2">if </span><span class="s1">proc</span><span class="s3">.</span><span class="s1">stdout</span><span class="s3">:</span>
                <span class="s1">proc</span><span class="s3">.</span><span class="s1">stdout</span><span class="s3">.</span><span class="s1">close</span><span class="s3">()</span>
            <span class="s2">if </span><span class="s1">proc</span><span class="s3">.</span><span class="s1">stderr</span><span class="s3">:</span>
                <span class="s1">proc</span><span class="s3">.</span><span class="s1">stderr</span><span class="s3">.</span><span class="s1">close</span><span class="s3">()</span>
            <span class="s0"># Did the process finish already so we have a return code?</span>
            <span class="s2">try</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">proc</span><span class="s3">.</span><span class="s1">poll</span><span class="s3">() </span><span class="s2">is not None</span><span class="s3">:</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">status </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_status_code_if_terminate </span><span class="s2">or </span><span class="s1">proc</span><span class="s3">.</span><span class="s1">poll</span><span class="s3">()</span>
                    <span class="s2">return</span>
            <span class="s2">except </span><span class="s1">OSError </span><span class="s2">as </span><span class="s1">ex</span><span class="s3">:</span>
                <span class="s1">_logger</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s4">&quot;Ignored error after process had died: %r&quot;</span><span class="s3">, </span><span class="s1">ex</span><span class="s3">)</span>

            <span class="s0"># It can be that nothing really exists anymore...</span>
            <span class="s2">if </span><span class="s1">os </span><span class="s2">is None or </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">os</span><span class="s3">, </span><span class="s4">&quot;kill&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">) </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s2">return</span>

            <span class="s0"># Try to kill it.</span>
            <span class="s2">try</span><span class="s3">:</span>
                <span class="s1">proc</span><span class="s3">.</span><span class="s1">terminate</span><span class="s3">()</span>
                <span class="s1">status </span><span class="s3">= </span><span class="s1">proc</span><span class="s3">.</span><span class="s1">wait</span><span class="s3">()  </span><span class="s0"># Ensure the process goes away.</span>

                <span class="s1">self</span><span class="s3">.</span><span class="s1">status </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_status_code_if_terminate </span><span class="s2">or </span><span class="s1">status</span>
            <span class="s2">except </span><span class="s1">OSError </span><span class="s2">as </span><span class="s1">ex</span><span class="s3">:</span>
                <span class="s1">_logger</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s4">&quot;Ignored error after process had died: %r&quot;</span><span class="s3">, </span><span class="s1">ex</span><span class="s3">)</span>
            <span class="s0"># END exception handling</span>

        <span class="s2">def </span><span class="s1">__del__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_terminate</span><span class="s3">()</span>

        <span class="s2">def </span><span class="s1">__getattr__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; Any</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">proc</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">)</span>

        <span class="s0"># TODO: Bad choice to mimic `proc.wait()` but with different args.</span>
        <span class="s2">def </span><span class="s1">wait</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">stderr</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s2">None</span><span class="s3">, </span><span class="s1">str</span><span class="s3">, </span><span class="s1">bytes</span><span class="s3">] = </span><span class="s7">b&quot;&quot;</span><span class="s3">) </span><span class="s1">-&gt; int</span><span class="s3">:</span>
            <span class="s5">&quot;&quot;&quot;Wait for the process and return its status code. 
 
            :param stderr: 
                Previously read value of stderr, in case stderr is already closed. 
 
            :warn: 
                May deadlock if output or error pipes are used and not handled 
                separately. 
 
            :raise git.exc.GitCommandError: 
                If the return status is not 0. 
            &quot;&quot;&quot;</span>
            <span class="s2">if </span><span class="s1">stderr </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s1">stderr_b </span><span class="s3">= </span><span class="s7">b&quot;&quot;</span>
            <span class="s1">stderr_b </span><span class="s3">= </span><span class="s1">force_bytes</span><span class="s3">(</span><span class="s1">data</span><span class="s3">=</span><span class="s1">stderr</span><span class="s3">, </span><span class="s1">encoding</span><span class="s3">=</span><span class="s4">&quot;utf-8&quot;</span><span class="s3">)</span>
            <span class="s1">status</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">int</span><span class="s3">, </span><span class="s2">None</span><span class="s3">]</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">proc </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s1">status </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">proc</span><span class="s3">.</span><span class="s1">wait</span><span class="s3">()</span>
                <span class="s1">p_stderr </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">proc</span><span class="s3">.</span><span class="s1">stderr</span>
            <span class="s2">else</span><span class="s3">:  </span><span class="s0"># Assume the underlying proc was killed earlier or never existed.</span>
                <span class="s1">status </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">status</span>
                <span class="s1">p_stderr </span><span class="s3">= </span><span class="s2">None</span>

            <span class="s2">def </span><span class="s1">read_all_from_possibly_closed_stream</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">IO</span><span class="s3">[</span><span class="s1">bytes</span><span class="s3">], </span><span class="s2">None</span><span class="s3">]) </span><span class="s1">-&gt; bytes</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">stream</span><span class="s3">:</span>
                    <span class="s2">try</span><span class="s3">:</span>
                        <span class="s2">return </span><span class="s1">stderr_b </span><span class="s3">+ </span><span class="s1">force_bytes</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">.</span><span class="s1">read</span><span class="s3">())</span>
                    <span class="s2">except </span><span class="s3">(</span><span class="s1">OSError</span><span class="s3">, </span><span class="s1">ValueError</span><span class="s3">):</span>
                        <span class="s2">return </span><span class="s1">stderr_b </span><span class="s2">or </span><span class="s7">b&quot;&quot;</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s2">return </span><span class="s1">stderr_b </span><span class="s2">or </span><span class="s7">b&quot;&quot;</span>

            <span class="s0"># END status handling</span>

            <span class="s2">if </span><span class="s1">status </span><span class="s3">!= </span><span class="s6">0</span><span class="s3">:</span>
                <span class="s1">errstr </span><span class="s3">= </span><span class="s1">read_all_from_possibly_closed_stream</span><span class="s3">(</span><span class="s1">p_stderr</span><span class="s3">)</span>
                <span class="s1">_logger</span><span class="s3">.</span><span class="s1">debug</span><span class="s3">(</span><span class="s4">&quot;AutoInterrupt wait stderr: %r&quot; </span><span class="s3">% (</span><span class="s1">errstr</span><span class="s3">,))</span>
                <span class="s2">raise </span><span class="s1">GitCommandError</span><span class="s3">(</span><span class="s1">remove_password_if_present</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">args</span><span class="s3">), </span><span class="s1">status</span><span class="s3">, </span><span class="s1">errstr</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">status</span>

    <span class="s0"># END auto interrupt</span>

    <span class="s2">class </span><span class="s1">CatFileContentStream</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Object representing a sized read-only stream returning the contents of 
        an object. 
 
        This behaves like a stream, but counts the data read and simulates an empty 
        stream once our sized content region is empty. 
 
        If not all data are read to the end of the object's lifetime, we read the 
        rest to ensure the underlying stream continues to work. 
        &quot;&quot;&quot;</span>

        <span class="s1">__slots__ </span><span class="s3">= (</span><span class="s4">&quot;_stream&quot;</span><span class="s3">, </span><span class="s4">&quot;_nbr&quot;</span><span class="s3">, </span><span class="s4">&quot;_size&quot;</span><span class="s3">)</span>

        <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">size</span><span class="s3">: </span><span class="s1">int</span><span class="s3">, </span><span class="s1">stream</span><span class="s3">: </span><span class="s1">IO</span><span class="s3">[</span><span class="s1">bytes</span><span class="s3">]) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_stream </span><span class="s3">= </span><span class="s1">stream</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_size </span><span class="s3">= </span><span class="s1">size</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_nbr </span><span class="s3">= </span><span class="s6">0  </span><span class="s0"># Number of bytes read.</span>

            <span class="s0"># Special case: If the object is empty, has null bytes, get the final</span>
            <span class="s0"># newline right away.</span>
            <span class="s2">if </span><span class="s1">size </span><span class="s3">== </span><span class="s6">0</span><span class="s3">:</span>
                <span class="s1">stream</span><span class="s3">.</span><span class="s1">read</span><span class="s3">(</span><span class="s6">1</span><span class="s3">)</span>
            <span class="s0"># END handle empty streams</span>

        <span class="s2">def </span><span class="s1">read</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">size</span><span class="s3">: </span><span class="s1">int </span><span class="s3">= -</span><span class="s6">1</span><span class="s3">) </span><span class="s1">-&gt; bytes</span><span class="s3">:</span>
            <span class="s1">bytes_left </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_size </span><span class="s3">- </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_nbr</span>
            <span class="s2">if </span><span class="s1">bytes_left </span><span class="s3">== </span><span class="s6">0</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s7">b&quot;&quot;</span>
            <span class="s2">if </span><span class="s1">size </span><span class="s3">&gt; -</span><span class="s6">1</span><span class="s3">:</span>
                <span class="s0"># Ensure we don't try to read past our limit.</span>
                <span class="s1">size </span><span class="s3">= </span><span class="s1">min</span><span class="s3">(</span><span class="s1">bytes_left</span><span class="s3">, </span><span class="s1">size</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s0"># They try to read all, make sure it's not more than what remains.</span>
                <span class="s1">size </span><span class="s3">= </span><span class="s1">bytes_left</span>
            <span class="s0"># END check early depletion</span>
            <span class="s1">data </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_stream</span><span class="s3">.</span><span class="s1">read</span><span class="s3">(</span><span class="s1">size</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_nbr </span><span class="s3">+= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">data</span><span class="s3">)</span>

            <span class="s0"># Check for depletion, read our final byte to make the stream usable by</span>
            <span class="s0"># others.</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_size </span><span class="s3">- </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_nbr </span><span class="s3">== </span><span class="s6">0</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_stream</span><span class="s3">.</span><span class="s1">read</span><span class="s3">(</span><span class="s6">1</span><span class="s3">)  </span><span class="s0"># final newline</span>
            <span class="s0"># END finish reading</span>
            <span class="s2">return </span><span class="s1">data</span>

        <span class="s2">def </span><span class="s1">readline</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">size</span><span class="s3">: </span><span class="s1">int </span><span class="s3">= -</span><span class="s6">1</span><span class="s3">) </span><span class="s1">-&gt; bytes</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_nbr </span><span class="s3">== </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_size</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s7">b&quot;&quot;</span>

            <span class="s0"># Clamp size to lowest allowed value.</span>
            <span class="s1">bytes_left </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_size </span><span class="s3">- </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_nbr</span>
            <span class="s2">if </span><span class="s1">size </span><span class="s3">&gt; -</span><span class="s6">1</span><span class="s3">:</span>
                <span class="s1">size </span><span class="s3">= </span><span class="s1">min</span><span class="s3">(</span><span class="s1">bytes_left</span><span class="s3">, </span><span class="s1">size</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">size </span><span class="s3">= </span><span class="s1">bytes_left</span>
            <span class="s0"># END handle size</span>

            <span class="s1">data </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_stream</span><span class="s3">.</span><span class="s1">readline</span><span class="s3">(</span><span class="s1">size</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_nbr </span><span class="s3">+= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">data</span><span class="s3">)</span>

            <span class="s0"># Handle final byte.</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_size </span><span class="s3">- </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_nbr </span><span class="s3">== </span><span class="s6">0</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_stream</span><span class="s3">.</span><span class="s1">read</span><span class="s3">(</span><span class="s6">1</span><span class="s3">)</span>
            <span class="s0"># END finish reading</span>

            <span class="s2">return </span><span class="s1">data</span>

        <span class="s2">def </span><span class="s1">readlines</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">size</span><span class="s3">: </span><span class="s1">int </span><span class="s3">= -</span><span class="s6">1</span><span class="s3">) </span><span class="s1">-&gt; List</span><span class="s3">[</span><span class="s1">bytes</span><span class="s3">]:</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_nbr </span><span class="s3">== </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_size</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s3">[]</span>

            <span class="s0"># Leave all additional logic to our readline method, we just check the size.</span>
            <span class="s1">out </span><span class="s3">= []</span>
            <span class="s1">nbr </span><span class="s3">= </span><span class="s6">0</span>
            <span class="s2">while True</span><span class="s3">:</span>
                <span class="s1">line </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">readline</span><span class="s3">()</span>
                <span class="s2">if not </span><span class="s1">line</span><span class="s3">:</span>
                    <span class="s2">break</span>
                <span class="s1">out</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">line</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">size </span><span class="s3">&gt; -</span><span class="s6">1</span><span class="s3">:</span>
                    <span class="s1">nbr </span><span class="s3">+= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">line</span><span class="s3">)</span>
                    <span class="s2">if </span><span class="s1">nbr </span><span class="s3">&gt; </span><span class="s1">size</span><span class="s3">:</span>
                        <span class="s2">break</span>
                <span class="s0"># END handle size constraint</span>
            <span class="s0"># END readline loop</span>
            <span class="s2">return </span><span class="s1">out</span>

        <span class="s0"># skipcq: PYL-E0301</span>
        <span class="s2">def </span><span class="s1">__iter__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s4">&quot;Git.CatFileContentStream&quot;</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span>

        <span class="s2">def </span><span class="s1">__next__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; bytes</span><span class="s3">:</span>
            <span class="s1">line </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">readline</span><span class="s3">()</span>
            <span class="s2">if not </span><span class="s1">line</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">StopIteration</span>

            <span class="s2">return </span><span class="s1">line</span>

        <span class="s1">next </span><span class="s3">= </span><span class="s1">__next__</span>

        <span class="s2">def </span><span class="s1">__del__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
            <span class="s1">bytes_left </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_size </span><span class="s3">- </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_nbr</span>
            <span class="s2">if </span><span class="s1">bytes_left</span><span class="s3">:</span>
                <span class="s0"># Read and discard - seeking is impossible within a stream.</span>
                <span class="s0"># This includes any terminating newline.</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_stream</span><span class="s3">.</span><span class="s1">read</span><span class="s3">(</span><span class="s1">bytes_left </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">)</span>
            <span class="s0"># END handle incomplete read</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">working_dir</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s2">None</span><span class="s3">, </span><span class="s1">PathLike</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Initialize this instance with: 
 
        :param working_dir: 
            Git directory we should work in. If ``None``, we always work in the current 
            directory as returned by :func:`os.getcwd`. 
            This is meant to be the working tree directory if available, or the 
            ``.git`` directory in case of bare repositories. 
        &quot;&quot;&quot;</span>
        <span class="s1">super</span><span class="s3">().</span><span class="s1">__init__</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_working_dir </span><span class="s3">= </span><span class="s1">expand_path</span><span class="s3">(</span><span class="s1">working_dir</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_git_options</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">List</span><span class="s3">[</span><span class="s1">str</span><span class="s3">], </span><span class="s1">Tuple</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, ...]] = ()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_persistent_git_options</span><span class="s3">: </span><span class="s1">List</span><span class="s3">[</span><span class="s1">str</span><span class="s3">] = []</span>

        <span class="s0"># Extra environment variables to pass to git commands</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_environment</span><span class="s3">: </span><span class="s1">Dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">str</span><span class="s3">] = {}</span>

        <span class="s0"># Cached version slots</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_version_info</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">Tuple</span><span class="s3">[</span><span class="s1">int</span><span class="s3">, ...], </span><span class="s2">None</span><span class="s3">] = </span><span class="s2">None</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_version_info_token</span><span class="s3">: </span><span class="s1">object </span><span class="s3">= </span><span class="s2">None</span>

        <span class="s0"># Cached command slots</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">cat_file_header</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s2">None</span><span class="s3">, </span><span class="s1">TBD</span><span class="s3">] = </span><span class="s2">None</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">cat_file_all</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s2">None</span><span class="s3">, </span><span class="s1">TBD</span><span class="s3">] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">__getattribute__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; Any</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s3">== </span><span class="s4">&quot;USE_SHELL&quot;</span><span class="s3">:</span>
            <span class="s1">_warn_use_shell</span><span class="s3">(</span><span class="s2">False</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">super</span><span class="s3">().</span><span class="s1">__getattribute__</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__getattr__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; Any</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;A convenience method as it allows to call the command as if it was an object. 
 
        :return: 
            Callable object that will execute call :meth:`_call_process` with your 
            arguments. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">name</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s4">&quot;_&quot;</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">super</span><span class="s3">().</span><span class="s1">__getattribute__</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>
        <span class="s2">return lambda </span><span class="s3">*</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_call_process</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">set_persistent_git_options</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Specify command line options to the git executable for subsequent 
        subcommand calls. 
 
        :param kwargs: 
            A dict of keyword arguments. 
            These arguments are passed as in :meth:`_call_process`, but will be passed 
            to the git command rather than the subcommand. 
        &quot;&quot;&quot;</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">_persistent_git_options </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">transform_kwargs</span><span class="s3">(</span><span class="s1">split_single_char_options</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">working_dir</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; Union</span><span class="s3">[</span><span class="s2">None</span><span class="s3">, </span><span class="s1">PathLike</span><span class="s3">]:</span>
        <span class="s5">&quot;&quot;&quot;:return: Git directory we are working on&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_working_dir</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">version_info</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; Tuple</span><span class="s3">[</span><span class="s1">int</span><span class="s3">, ...]:</span>
        <span class="s5">&quot;&quot;&quot; 
        :return: Tuple with integers representing the major, minor and additional 
            version numbers as parsed from :manpage:`git-version(1)`. Up to four fields 
            are used. 
 
            This value is generated on demand and is cached. 
        &quot;&quot;&quot;</span>
        <span class="s0"># Refreshing is global, but version_info caching is per-instance.</span>
        <span class="s1">refresh_token </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_refresh_token  </span><span class="s0"># Copy token in case of concurrent refresh.</span>

        <span class="s0"># Use the cached version if obtained after the most recent refresh.</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_version_info_token </span><span class="s2">is </span><span class="s1">refresh_token</span><span class="s3">:</span>
            <span class="s2">assert </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_version_info </span><span class="s2">is not None</span><span class="s3">, </span><span class="s4">&quot;Bug: corrupted token-check state&quot;</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_version_info</span>

        <span class="s0"># Run &quot;git version&quot; and parse it.</span>
        <span class="s1">process_version </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_call_process</span><span class="s3">(</span><span class="s4">&quot;version&quot;</span><span class="s3">)</span>
        <span class="s1">version_string </span><span class="s3">= </span><span class="s1">process_version</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s4">&quot; &quot;</span><span class="s3">)[</span><span class="s6">2</span><span class="s3">]</span>
        <span class="s1">version_fields </span><span class="s3">= </span><span class="s1">version_string</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s4">&quot;.&quot;</span><span class="s3">)[:</span><span class="s6">4</span><span class="s3">]</span>
        <span class="s1">leading_numeric_fields </span><span class="s3">= </span><span class="s1">itertools</span><span class="s3">.</span><span class="s1">takewhile</span><span class="s3">(</span><span class="s1">str</span><span class="s3">.</span><span class="s1">isdigit</span><span class="s3">, </span><span class="s1">version_fields</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_version_info </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">map</span><span class="s3">(</span><span class="s1">int</span><span class="s3">, </span><span class="s1">leading_numeric_fields</span><span class="s3">))</span>

        <span class="s0"># This value will be considered valid until the next refresh.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_version_info_token </span><span class="s3">= </span><span class="s1">refresh_token</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_version_info</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s2">def </span><span class="s1">execute</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">command</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Sequence</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">]],</span>
        <span class="s3">*,</span>
        <span class="s1">as_process</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s2">True</span><span class="s3">],</span>
    <span class="s3">) </span><span class="s1">-&gt; </span><span class="s4">&quot;AutoInterrupt&quot;</span><span class="s3">: ...</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s2">def </span><span class="s1">execute</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">command</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Sequence</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">]],</span>
        <span class="s3">*,</span>
        <span class="s1">as_process</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s2">False</span><span class="s3">] = </span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">stdout_as_string</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s2">True</span><span class="s3">],</span>
    <span class="s3">) </span><span class="s1">-&gt; Union</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Tuple</span><span class="s3">[</span><span class="s1">int</span><span class="s3">, </span><span class="s1">str</span><span class="s3">, </span><span class="s1">str</span><span class="s3">]]: ...</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s2">def </span><span class="s1">execute</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">command</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Sequence</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">]],</span>
        <span class="s3">*,</span>
        <span class="s1">as_process</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s2">False</span><span class="s3">] = </span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">stdout_as_string</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s2">False</span><span class="s3">] = </span><span class="s2">False</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; Union</span><span class="s3">[</span><span class="s1">bytes</span><span class="s3">, </span><span class="s1">Tuple</span><span class="s3">[</span><span class="s1">int</span><span class="s3">, </span><span class="s1">bytes</span><span class="s3">, </span><span class="s1">str</span><span class="s3">]]: ...</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s2">def </span><span class="s1">execute</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">command</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Sequence</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">]],</span>
        <span class="s3">*,</span>
        <span class="s1">with_extended_output</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s2">False</span><span class="s3">],</span>
        <span class="s1">as_process</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s2">False</span><span class="s3">],</span>
        <span class="s1">stdout_as_string</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s2">True</span><span class="s3">],</span>
    <span class="s3">) </span><span class="s1">-&gt; str</span><span class="s3">: ...</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s2">def </span><span class="s1">execute</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">command</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Sequence</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">]],</span>
        <span class="s3">*,</span>
        <span class="s1">with_extended_output</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s2">False</span><span class="s3">],</span>
        <span class="s1">as_process</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s2">False</span><span class="s3">],</span>
        <span class="s1">stdout_as_string</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s2">False</span><span class="s3">],</span>
    <span class="s3">) </span><span class="s1">-&gt; bytes</span><span class="s3">: ...</span>

    <span class="s2">def </span><span class="s1">execute</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">command</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Sequence</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">]],</span>
        <span class="s1">istream</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s2">None</span><span class="s3">, </span><span class="s1">BinaryIO</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">with_extended_output</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">with_exceptions</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">,</span>
        <span class="s1">as_process</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">output_stream</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s2">None</span><span class="s3">, </span><span class="s1">BinaryIO</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">stdout_as_string</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">,</span>
        <span class="s1">kill_after_timeout</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s2">None</span><span class="s3">, </span><span class="s1">float</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">with_stdout</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">,</span>
        <span class="s1">universal_newlines</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">shell</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s2">None</span><span class="s3">, </span><span class="s1">bool</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">env</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s2">None</span><span class="s3">, </span><span class="s1">Mapping</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">str</span><span class="s3">]] = </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">max_chunk_size</span><span class="s3">: </span><span class="s1">int </span><span class="s3">= </span><span class="s1">io</span><span class="s3">.</span><span class="s1">DEFAULT_BUFFER_SIZE</span><span class="s3">,</span>
        <span class="s1">strip_newline_in_stdout</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">,</span>
        <span class="s3">**</span><span class="s1">subprocess_kwargs</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; Union</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">bytes</span><span class="s3">, </span><span class="s1">Tuple</span><span class="s3">[</span><span class="s1">int</span><span class="s3">, </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">bytes</span><span class="s3">], </span><span class="s1">str</span><span class="s3">], </span><span class="s1">AutoInterrupt</span><span class="s3">]:</span>
        <span class="s5">R&quot;&quot;&quot;Handle executing the command, and consume and return the returned 
        information (stdout). 
 
        :param command: 
            The command argument list to execute. 
            It should be a sequence of program arguments, or a string. The 
            program to execute is the first item in the args sequence or string. 
 
        :param istream: 
            Standard input filehandle passed to :class:`subprocess.Popen`. 
 
        :param with_extended_output: 
            Whether to return a (status, stdout, stderr) tuple. 
 
        :param with_exceptions: 
            Whether to raise an exception when git returns a non-zero status. 
 
        :param as_process: 
            Whether to return the created process instance directly from which 
            streams can be read on demand. This will render `with_extended_output` 
            and `with_exceptions` ineffective - the caller will have to deal with 
            the details. It is important to note that the process will be placed 
            into an :class:`AutoInterrupt` wrapper that will interrupt the process 
            once it goes out of scope. If you use the command in iterators, you 
            should pass the whole process instance instead of a single stream. 
 
        :param output_stream: 
            If set to a file-like object, data produced by the git command will be 
            copied to the given stream instead of being returned as a string. 
            This feature only has any effect if `as_process` is ``False``. 
 
        :param stdout_as_string: 
            If ``False``, the command's standard output will be bytes. Otherwise, it 
            will be decoded into a string using the default encoding (usually UTF-8). 
            The latter can fail, if the output contains binary data. 
 
        :param kill_after_timeout: 
            Specifies a timeout in seconds for the git command, after which the process 
            should be killed. This will have no effect if `as_process` is set to 
            ``True``. It is set to ``None`` by default and will let the process run 
            until the timeout is explicitly specified. Uses of this feature should be 
            carefully considered, due to the following limitations: 
 
            1. This feature is not supported at all on Windows. 
            2. Effectiveness may vary by operating system. ``ps --ppid`` is used to 
               enumerate child processes, which is available on most GNU/Linux systems 
               but not most others. 
            3. Deeper descendants do not receive signals, though they may sometimes 
               terminate as a consequence of their parent processes being killed. 
            4. `kill_after_timeout` uses ``SIGKILL``, which can have negative side 
               effects on a repository. For example, stale locks in case of 
               :manpage:`git-gc(1)` could render the repository incapable of accepting 
               changes until the lock is manually removed. 
 
        :param with_stdout: 
            If ``True``, default ``True``, we open stdout on the created process. 
 
        :param universal_newlines: 
            If ``True``, pipes will be opened as text, and lines are split at all known 
            line endings. 
 
        :param shell: 
            Whether to invoke commands through a shell 
            (see :class:`Popen(..., shell=True) &lt;subprocess.Popen&gt;`). 
            If this is not ``None``, it overrides :attr:`USE_SHELL`. 
 
            Passing ``shell=True`` to this or any other GitPython function should be 
            avoided, as it is unsafe under most circumstances. This is because it is 
            typically not feasible to fully consider and account for the effect of shell 
            expansions, especially when passing ``shell=True`` to other methods that 
            forward it to :meth:`Git.execute`. Passing ``shell=True`` is also no longer 
            needed (nor useful) to work around any known operating system specific 
            issues. 
 
        :param env: 
            A dictionary of environment variables to be passed to 
            :class:`subprocess.Popen`. 
 
        :param max_chunk_size: 
            Maximum number of bytes in one chunk of data passed to the `output_stream` 
            in one invocation of its ``write()`` method. If the given number is not 
            positive then the default value is used. 
 
        :param strip_newline_in_stdout: 
            Whether to strip the trailing ``\n`` of the command stdout. 
 
        :param subprocess_kwargs: 
            Keyword arguments to be passed to :class:`subprocess.Popen`. Please note 
            that some of the valid kwargs are already set by this method; the ones you 
            specify may not be the same ones. 
 
        :return: 
            * str(output), if `extended_output` is ``False`` (Default) 
            * tuple(int(status), str(stdout), str(stderr)), 
              if `extended_output` is ``True`` 
 
            If `output_stream` is ``True``, the stdout value will be your output stream: 
 
            * output_stream, if `extended_output` is ``False`` 
            * tuple(int(status), output_stream, str(stderr)), 
              if `extended_output` is ``True`` 
 
            Note that git is executed with ``LC_MESSAGES=&quot;C&quot;`` to ensure consistent 
            output regardless of system language. 
 
        :raise git.exc.GitCommandError: 
 
        :note: 
            If you add additional keyword arguments to the signature of this method, you 
            must update the ``execute_kwargs`` variable housed in this module. 
        &quot;&quot;&quot;</span>
        <span class="s0"># Remove password for the command if present.</span>
        <span class="s1">redacted_command </span><span class="s3">= </span><span class="s1">remove_password_if_present</span><span class="s3">(</span><span class="s1">command</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">GIT_PYTHON_TRACE </span><span class="s2">and </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">GIT_PYTHON_TRACE </span><span class="s3">!= </span><span class="s4">&quot;full&quot; </span><span class="s2">or </span><span class="s1">as_process</span><span class="s3">):</span>
            <span class="s1">_logger</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s4">&quot; &quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">redacted_command</span><span class="s3">))</span>

        <span class="s0"># Allow the user to have the command executed in their working dir.</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">cwd </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_working_dir </span><span class="s2">or </span><span class="s1">os</span><span class="s3">.</span><span class="s1">getcwd</span><span class="s3">()  </span><span class="s0"># type: Union[None, str]</span>
            <span class="s2">if not </span><span class="s1">os</span><span class="s3">.</span><span class="s1">access</span><span class="s3">(</span><span class="s1">str</span><span class="s3">(</span><span class="s1">cwd</span><span class="s3">), </span><span class="s1">os</span><span class="s3">.</span><span class="s1">X_OK</span><span class="s3">):</span>
                <span class="s1">cwd </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s2">except </span><span class="s1">FileNotFoundError</span><span class="s3">:</span>
            <span class="s1">cwd </span><span class="s3">= </span><span class="s2">None</span>

        <span class="s0"># Start the process.</span>
        <span class="s1">inline_env </span><span class="s3">= </span><span class="s1">env</span>
        <span class="s1">env </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">environ</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
        <span class="s0"># Attempt to force all output to plain ASCII English, which is what some parsing</span>
        <span class="s0"># code may expect.</span>
        <span class="s0"># According to https://askubuntu.com/a/311796, we are setting LANGUAGE as well</span>
        <span class="s0"># just to be sure.</span>
        <span class="s1">env</span><span class="s3">[</span><span class="s4">&quot;LANGUAGE&quot;</span><span class="s3">] = </span><span class="s4">&quot;C&quot;</span>
        <span class="s1">env</span><span class="s3">[</span><span class="s4">&quot;LC_ALL&quot;</span><span class="s3">] = </span><span class="s4">&quot;C&quot;</span>
        <span class="s1">env</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_environment</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">inline_env </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">env</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">inline_env</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">platform </span><span class="s3">== </span><span class="s4">&quot;win32&quot;</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">kill_after_timeout </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">GitCommandError</span><span class="s3">(</span>
                    <span class="s1">redacted_command</span><span class="s3">,</span>
                    <span class="s4">'&quot;kill_after_timeout&quot; feature is not supported on Windows.'</span><span class="s3">,</span>
                <span class="s3">)</span>
            <span class="s1">cmd_not_found_exception </span><span class="s3">= </span><span class="s1">OSError</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">cmd_not_found_exception </span><span class="s3">= </span><span class="s1">FileNotFoundError</span>
        <span class="s0"># END handle</span>

        <span class="s1">stdout_sink </span><span class="s3">= </span><span class="s1">PIPE </span><span class="s2">if </span><span class="s1">with_stdout </span><span class="s2">else </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">subprocess</span><span class="s3">, </span><span class="s4">&quot;DEVNULL&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">) </span><span class="s2">or </span><span class="s1">open</span><span class="s3">(</span><span class="s1">os</span><span class="s3">.</span><span class="s1">devnull</span><span class="s3">, </span><span class="s4">&quot;wb&quot;</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">shell </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s0"># Get the value of USE_SHELL with no deprecation warning. Do this without</span>
            <span class="s0"># warnings.catch_warnings, to avoid a race condition with application code</span>
            <span class="s0"># configuring warnings. The value could be looked up in type(self).__dict__</span>
            <span class="s0"># or Git.__dict__, but those can break under some circumstances. This works</span>
            <span class="s0"># the same as self.USE_SHELL in more situations; see Git.__getattribute__.</span>
            <span class="s1">shell </span><span class="s3">= </span><span class="s1">super</span><span class="s3">().</span><span class="s1">__getattribute__</span><span class="s3">(</span><span class="s4">&quot;USE_SHELL&quot;</span><span class="s3">)</span>
        <span class="s1">_logger</span><span class="s3">.</span><span class="s1">debug</span><span class="s3">(</span>
            <span class="s4">&quot;Popen(%s, cwd=%s, stdin=%s, shell=%s, universal_newlines=%s)&quot;</span><span class="s3">,</span>
            <span class="s1">redacted_command</span><span class="s3">,</span>
            <span class="s1">cwd</span><span class="s3">,</span>
            <span class="s4">&quot;&lt;valid stream&gt;&quot; </span><span class="s2">if </span><span class="s1">istream </span><span class="s2">else </span><span class="s4">&quot;None&quot;</span><span class="s3">,</span>
            <span class="s1">shell</span><span class="s3">,</span>
            <span class="s1">universal_newlines</span><span class="s3">,</span>
        <span class="s3">)</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">proc </span><span class="s3">= </span><span class="s1">safer_popen</span><span class="s3">(</span>
                <span class="s1">command</span><span class="s3">,</span>
                <span class="s1">env</span><span class="s3">=</span><span class="s1">env</span><span class="s3">,</span>
                <span class="s1">cwd</span><span class="s3">=</span><span class="s1">cwd</span><span class="s3">,</span>
                <span class="s1">bufsize</span><span class="s3">=-</span><span class="s6">1</span><span class="s3">,</span>
                <span class="s1">stdin</span><span class="s3">=(</span><span class="s1">istream </span><span class="s2">or </span><span class="s1">DEVNULL</span><span class="s3">),</span>
                <span class="s1">stderr</span><span class="s3">=</span><span class="s1">PIPE</span><span class="s3">,</span>
                <span class="s1">stdout</span><span class="s3">=</span><span class="s1">stdout_sink</span><span class="s3">,</span>
                <span class="s1">shell</span><span class="s3">=</span><span class="s1">shell</span><span class="s3">,</span>
                <span class="s1">universal_newlines</span><span class="s3">=</span><span class="s1">universal_newlines</span><span class="s3">,</span>
                <span class="s3">**</span><span class="s1">subprocess_kwargs</span><span class="s3">,</span>
            <span class="s3">)</span>
        <span class="s2">except </span><span class="s1">cmd_not_found_exception </span><span class="s2">as </span><span class="s1">err</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">GitCommandNotFound</span><span class="s3">(</span><span class="s1">redacted_command</span><span class="s3">, </span><span class="s1">err</span><span class="s3">) </span><span class="s2">from </span><span class="s1">err</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s0"># Replace with a typeguard for Popen[bytes]?</span>
            <span class="s1">proc</span><span class="s3">.</span><span class="s1">stdout </span><span class="s3">= </span><span class="s1">cast</span><span class="s3">(</span><span class="s1">BinaryIO</span><span class="s3">, </span><span class="s1">proc</span><span class="s3">.</span><span class="s1">stdout</span><span class="s3">)</span>
            <span class="s1">proc</span><span class="s3">.</span><span class="s1">stderr </span><span class="s3">= </span><span class="s1">cast</span><span class="s3">(</span><span class="s1">BinaryIO</span><span class="s3">, </span><span class="s1">proc</span><span class="s3">.</span><span class="s1">stderr</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">as_process</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">AutoInterrupt</span><span class="s3">(</span><span class="s1">proc</span><span class="s3">, </span><span class="s1">command</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">platform </span><span class="s3">!= </span><span class="s4">&quot;win32&quot; </span><span class="s2">and </span><span class="s1">kill_after_timeout </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s0"># Help mypy figure out this is not None even when used inside communicate().</span>
            <span class="s1">timeout </span><span class="s3">= </span><span class="s1">kill_after_timeout</span>

            <span class="s2">def </span><span class="s1">kill_process</span><span class="s3">(</span><span class="s1">pid</span><span class="s3">: </span><span class="s1">int</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
                <span class="s5">&quot;&quot;&quot;Callback to kill a process. 
 
                This callback implementation would be ineffective and unsafe on Windows. 
                &quot;&quot;&quot;</span>
                <span class="s1">p </span><span class="s3">= </span><span class="s1">Popen</span><span class="s3">([</span><span class="s4">&quot;ps&quot;</span><span class="s3">, </span><span class="s4">&quot;--ppid&quot;</span><span class="s3">, </span><span class="s1">str</span><span class="s3">(</span><span class="s1">pid</span><span class="s3">)], </span><span class="s1">stdout</span><span class="s3">=</span><span class="s1">PIPE</span><span class="s3">)</span>
                <span class="s1">child_pids </span><span class="s3">= []</span>
                <span class="s2">if </span><span class="s1">p</span><span class="s3">.</span><span class="s1">stdout </span><span class="s2">is not None</span><span class="s3">:</span>
                    <span class="s2">for </span><span class="s1">line </span><span class="s2">in </span><span class="s1">p</span><span class="s3">.</span><span class="s1">stdout</span><span class="s3">:</span>
                        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">line</span><span class="s3">.</span><span class="s1">split</span><span class="s3">()) &gt; </span><span class="s6">0</span><span class="s3">:</span>
                            <span class="s1">local_pid </span><span class="s3">= (</span><span class="s1">line</span><span class="s3">.</span><span class="s1">split</span><span class="s3">())[</span><span class="s6">0</span><span class="s3">]</span>
                            <span class="s2">if </span><span class="s1">local_pid</span><span class="s3">.</span><span class="s1">isdigit</span><span class="s3">():</span>
                                <span class="s1">child_pids</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">int</span><span class="s3">(</span><span class="s1">local_pid</span><span class="s3">))</span>
                <span class="s2">try</span><span class="s3">:</span>
                    <span class="s1">os</span><span class="s3">.</span><span class="s1">kill</span><span class="s3">(</span><span class="s1">pid</span><span class="s3">, </span><span class="s1">signal</span><span class="s3">.</span><span class="s1">SIGKILL</span><span class="s3">)</span>
                    <span class="s2">for </span><span class="s1">child_pid </span><span class="s2">in </span><span class="s1">child_pids</span><span class="s3">:</span>
                        <span class="s2">try</span><span class="s3">:</span>
                            <span class="s1">os</span><span class="s3">.</span><span class="s1">kill</span><span class="s3">(</span><span class="s1">child_pid</span><span class="s3">, </span><span class="s1">signal</span><span class="s3">.</span><span class="s1">SIGKILL</span><span class="s3">)</span>
                        <span class="s2">except </span><span class="s1">OSError</span><span class="s3">:</span>
                            <span class="s2">pass</span>
                    <span class="s0"># Tell the main routine that the process was killed.</span>
                    <span class="s1">kill_check</span><span class="s3">.</span><span class="s1">set</span><span class="s3">()</span>
                <span class="s2">except </span><span class="s1">OSError</span><span class="s3">:</span>
                    <span class="s0"># It is possible that the process gets completed in the duration</span>
                    <span class="s0"># after timeout happens and before we try to kill the process.</span>
                    <span class="s2">pass</span>
                <span class="s2">return</span>

            <span class="s2">def </span><span class="s1">communicate</span><span class="s3">() </span><span class="s1">-&gt; Tuple</span><span class="s3">[</span><span class="s1">AnyStr</span><span class="s3">, </span><span class="s1">AnyStr</span><span class="s3">]:</span>
                <span class="s1">watchdog</span><span class="s3">.</span><span class="s1">start</span><span class="s3">()</span>
                <span class="s1">out</span><span class="s3">, </span><span class="s1">err </span><span class="s3">= </span><span class="s1">proc</span><span class="s3">.</span><span class="s1">communicate</span><span class="s3">()</span>
                <span class="s1">watchdog</span><span class="s3">.</span><span class="s1">cancel</span><span class="s3">()</span>
                <span class="s2">if </span><span class="s1">kill_check</span><span class="s3">.</span><span class="s1">is_set</span><span class="s3">():</span>
                    <span class="s1">err </span><span class="s3">= </span><span class="s4">'Timeout: the command &quot;%s&quot; did not complete in %d ' &quot;secs.&quot; </span><span class="s3">% (</span>
                        <span class="s4">&quot; &quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">redacted_command</span><span class="s3">),</span>
                        <span class="s1">timeout</span><span class="s3">,</span>
                    <span class="s3">)</span>
                    <span class="s2">if not </span><span class="s1">universal_newlines</span><span class="s3">:</span>
                        <span class="s1">err </span><span class="s3">= </span><span class="s1">err</span><span class="s3">.</span><span class="s1">encode</span><span class="s3">(</span><span class="s1">defenc</span><span class="s3">)</span>
                <span class="s2">return </span><span class="s1">out</span><span class="s3">, </span><span class="s1">err</span>

            <span class="s0"># END helpers</span>

            <span class="s1">kill_check </span><span class="s3">= </span><span class="s1">threading</span><span class="s3">.</span><span class="s1">Event</span><span class="s3">()</span>
            <span class="s1">watchdog </span><span class="s3">= </span><span class="s1">threading</span><span class="s3">.</span><span class="s1">Timer</span><span class="s3">(</span><span class="s1">timeout</span><span class="s3">, </span><span class="s1">kill_process</span><span class="s3">, </span><span class="s1">args</span><span class="s3">=(</span><span class="s1">proc</span><span class="s3">.</span><span class="s1">pid</span><span class="s3">,))</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">communicate </span><span class="s3">= </span><span class="s1">proc</span><span class="s3">.</span><span class="s1">communicate</span>

        <span class="s0"># Wait for the process to return.</span>
        <span class="s1">status </span><span class="s3">= </span><span class="s6">0</span>
        <span class="s1">stdout_value</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">bytes</span><span class="s3">] = </span><span class="s7">b&quot;&quot;</span>
        <span class="s1">stderr_value</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">bytes</span><span class="s3">] = </span><span class="s7">b&quot;&quot;</span>
        <span class="s1">newline </span><span class="s3">= </span><span class="s4">&quot;</span><span class="s2">\n</span><span class="s4">&quot; </span><span class="s2">if </span><span class="s1">universal_newlines </span><span class="s2">else </span><span class="s7">b&quot;</span><span class="s2">\n</span><span class="s7">&quot;</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">output_stream </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s1">stdout_value</span><span class="s3">, </span><span class="s1">stderr_value </span><span class="s3">= </span><span class="s1">communicate</span><span class="s3">()</span>
                <span class="s0"># Strip trailing &quot;\n&quot;.</span>
                <span class="s2">if </span><span class="s1">stdout_value</span><span class="s3">.</span><span class="s1">endswith</span><span class="s3">(</span><span class="s1">newline</span><span class="s3">) </span><span class="s2">and </span><span class="s1">strip_newline_in_stdout</span><span class="s3">:  </span><span class="s0"># type: ignore[arg-type]</span>
                    <span class="s1">stdout_value </span><span class="s3">= </span><span class="s1">stdout_value</span><span class="s3">[:-</span><span class="s6">1</span><span class="s3">]</span>
                <span class="s2">if </span><span class="s1">stderr_value</span><span class="s3">.</span><span class="s1">endswith</span><span class="s3">(</span><span class="s1">newline</span><span class="s3">):  </span><span class="s0"># type: ignore[arg-type]</span>
                    <span class="s1">stderr_value </span><span class="s3">= </span><span class="s1">stderr_value</span><span class="s3">[:-</span><span class="s6">1</span><span class="s3">]</span>

                <span class="s1">status </span><span class="s3">= </span><span class="s1">proc</span><span class="s3">.</span><span class="s1">returncode</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">max_chunk_size </span><span class="s3">= </span><span class="s1">max_chunk_size </span><span class="s2">if </span><span class="s1">max_chunk_size </span><span class="s2">and </span><span class="s1">max_chunk_size </span><span class="s3">&gt; </span><span class="s6">0 </span><span class="s2">else </span><span class="s1">io</span><span class="s3">.</span><span class="s1">DEFAULT_BUFFER_SIZE</span>
                <span class="s1">stream_copy</span><span class="s3">(</span><span class="s1">proc</span><span class="s3">.</span><span class="s1">stdout</span><span class="s3">, </span><span class="s1">output_stream</span><span class="s3">, </span><span class="s1">max_chunk_size</span><span class="s3">)</span>
                <span class="s1">stdout_value </span><span class="s3">= </span><span class="s1">proc</span><span class="s3">.</span><span class="s1">stdout</span><span class="s3">.</span><span class="s1">read</span><span class="s3">()</span>
                <span class="s1">stderr_value </span><span class="s3">= </span><span class="s1">proc</span><span class="s3">.</span><span class="s1">stderr</span><span class="s3">.</span><span class="s1">read</span><span class="s3">()</span>
                <span class="s0"># Strip trailing &quot;\n&quot;.</span>
                <span class="s2">if </span><span class="s1">stderr_value</span><span class="s3">.</span><span class="s1">endswith</span><span class="s3">(</span><span class="s1">newline</span><span class="s3">):  </span><span class="s0"># type: ignore[arg-type]</span>
                    <span class="s1">stderr_value </span><span class="s3">= </span><span class="s1">stderr_value</span><span class="s3">[:-</span><span class="s6">1</span><span class="s3">]</span>
                <span class="s1">status </span><span class="s3">= </span><span class="s1">proc</span><span class="s3">.</span><span class="s1">wait</span><span class="s3">()</span>
            <span class="s0"># END stdout handling</span>
        <span class="s2">finally</span><span class="s3">:</span>
            <span class="s1">proc</span><span class="s3">.</span><span class="s1">stdout</span><span class="s3">.</span><span class="s1">close</span><span class="s3">()</span>
            <span class="s1">proc</span><span class="s3">.</span><span class="s1">stderr</span><span class="s3">.</span><span class="s1">close</span><span class="s3">()</span>

        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">GIT_PYTHON_TRACE </span><span class="s3">== </span><span class="s4">&quot;full&quot;</span><span class="s3">:</span>
            <span class="s1">cmdstr </span><span class="s3">= </span><span class="s4">&quot; &quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">redacted_command</span><span class="s3">)</span>

            <span class="s2">def </span><span class="s1">as_text</span><span class="s3">(</span><span class="s1">stdout_value</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">bytes</span><span class="s3">, </span><span class="s1">str</span><span class="s3">]) </span><span class="s1">-&gt; str</span><span class="s3">:</span>
                <span class="s2">return not </span><span class="s1">output_stream </span><span class="s2">and </span><span class="s1">safe_decode</span><span class="s3">(</span><span class="s1">stdout_value</span><span class="s3">) </span><span class="s2">or </span><span class="s4">&quot;&lt;OUTPUT_STREAM&gt;&quot;</span>

            <span class="s0"># END as_text</span>

            <span class="s2">if </span><span class="s1">stderr_value</span><span class="s3">:</span>
                <span class="s1">_logger</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span>
                    <span class="s4">&quot;%s -&gt; %d; stdout: '%s'; stderr: '%s'&quot;</span><span class="s3">,</span>
                    <span class="s1">cmdstr</span><span class="s3">,</span>
                    <span class="s1">status</span><span class="s3">,</span>
                    <span class="s1">as_text</span><span class="s3">(</span><span class="s1">stdout_value</span><span class="s3">),</span>
                    <span class="s1">safe_decode</span><span class="s3">(</span><span class="s1">stderr_value</span><span class="s3">),</span>
                <span class="s3">)</span>
            <span class="s2">elif </span><span class="s1">stdout_value</span><span class="s3">:</span>
                <span class="s1">_logger</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s4">&quot;%s -&gt; %d; stdout: '%s'&quot;</span><span class="s3">, </span><span class="s1">cmdstr</span><span class="s3">, </span><span class="s1">status</span><span class="s3">, </span><span class="s1">as_text</span><span class="s3">(</span><span class="s1">stdout_value</span><span class="s3">))</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">_logger</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s4">&quot;%s -&gt; %d&quot;</span><span class="s3">, </span><span class="s1">cmdstr</span><span class="s3">, </span><span class="s1">status</span><span class="s3">)</span>
        <span class="s0"># END handle debug printing</span>

        <span class="s2">if </span><span class="s1">with_exceptions </span><span class="s2">and </span><span class="s1">status </span><span class="s3">!= </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">GitCommandError</span><span class="s3">(</span><span class="s1">redacted_command</span><span class="s3">, </span><span class="s1">status</span><span class="s3">, </span><span class="s1">stderr_value</span><span class="s3">, </span><span class="s1">stdout_value</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stdout_value</span><span class="s3">, </span><span class="s1">bytes</span><span class="s3">) </span><span class="s2">and </span><span class="s1">stdout_as_string</span><span class="s3">:  </span><span class="s0"># Could also be output_stream.</span>
            <span class="s1">stdout_value </span><span class="s3">= </span><span class="s1">safe_decode</span><span class="s3">(</span><span class="s1">stdout_value</span><span class="s3">)</span>

        <span class="s0"># Allow access to the command's status code.</span>
        <span class="s2">if </span><span class="s1">with_extended_output</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s3">(</span><span class="s1">status</span><span class="s3">, </span><span class="s1">stdout_value</span><span class="s3">, </span><span class="s1">safe_decode</span><span class="s3">(</span><span class="s1">stderr_value</span><span class="s3">))</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">stdout_value</span>

    <span class="s2">def </span><span class="s1">environment</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; Dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">str</span><span class="s3">]:</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_environment</span>

    <span class="s2">def </span><span class="s1">update_environment</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; Dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s2">None</span><span class="s3">]]:</span>
        <span class="s5">&quot;&quot;&quot;Set environment variables for future git invocations. Return all changed 
        values in a format that can be passed back into this function to revert the 
        changes. 
 
        Examples:: 
 
            old_env = self.update_environment(PWD='/tmp') 
            self.update_environment(**old_env) 
 
        :param kwargs: 
            Environment variables to use for git processes. 
 
        :return: 
            Dict that maps environment variables to their old values 
        &quot;&quot;&quot;</span>
        <span class="s1">old_env </span><span class="s3">= {}</span>
        <span class="s2">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">kwargs</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
            <span class="s0"># Set value if it is None.</span>
            <span class="s2">if </span><span class="s1">value </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s1">old_env</span><span class="s3">[</span><span class="s1">key</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_environment</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">key</span><span class="s3">)</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_environment</span><span class="s3">[</span><span class="s1">key</span><span class="s3">] = </span><span class="s1">value</span>
            <span class="s0"># Remove key from environment if its value is None.</span>
            <span class="s2">elif </span><span class="s1">key </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_environment</span><span class="s3">:</span>
                <span class="s1">old_env</span><span class="s3">[</span><span class="s1">key</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_environment</span><span class="s3">[</span><span class="s1">key</span><span class="s3">]</span>
                <span class="s2">del </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_environment</span><span class="s3">[</span><span class="s1">key</span><span class="s3">]</span>
        <span class="s2">return </span><span class="s1">old_env</span>

    <span class="s3">@</span><span class="s1">contextlib</span><span class="s3">.</span><span class="s1">contextmanager</span>
    <span class="s2">def </span><span class="s1">custom_environment</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; Iterator</span><span class="s3">[</span><span class="s2">None</span><span class="s3">]:</span>
        <span class="s5">&quot;&quot;&quot;A context manager around the above :meth:`update_environment` method to 
        restore the environment back to its previous state after operation. 
 
        Examples:: 
 
            with self.custom_environment(GIT_SSH='/bin/ssh_wrapper'): 
                repo.remotes.origin.fetch() 
 
        :param kwargs: 
            See :meth:`update_environment`. 
        &quot;&quot;&quot;</span>
        <span class="s1">old_env </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">update_environment</span><span class="s3">(**</span><span class="s1">kwargs</span><span class="s3">)</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s2">yield</span>
        <span class="s2">finally</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">update_environment</span><span class="s3">(**</span><span class="s1">old_env</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">transform_kwarg</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">, </span><span class="s1">value</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">, </span><span class="s1">split_single_char_options</span><span class="s3">: </span><span class="s1">bool</span><span class="s3">) </span><span class="s1">-&gt; List</span><span class="s3">[</span><span class="s1">str</span><span class="s3">]:</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">name</span><span class="s3">) == </span><span class="s6">1</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">value </span><span class="s2">is True</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s3">[</span><span class="s4">&quot;-%s&quot; </span><span class="s3">% </span><span class="s1">name</span><span class="s3">]</span>
            <span class="s2">elif </span><span class="s1">value </span><span class="s2">not in </span><span class="s3">(</span><span class="s2">False</span><span class="s3">, </span><span class="s2">None</span><span class="s3">):</span>
                <span class="s2">if </span><span class="s1">split_single_char_options</span><span class="s3">:</span>
                    <span class="s2">return </span><span class="s3">[</span><span class="s4">&quot;-%s&quot; </span><span class="s3">% </span><span class="s1">name</span><span class="s3">, </span><span class="s4">&quot;%s&quot; </span><span class="s3">% </span><span class="s1">value</span><span class="s3">]</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s2">return </span><span class="s3">[</span><span class="s4">&quot;-%s%s&quot; </span><span class="s3">% (</span><span class="s1">name</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)]</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">value </span><span class="s2">is True</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s3">[</span><span class="s4">&quot;--%s&quot; </span><span class="s3">% </span><span class="s1">dashify</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)]</span>
            <span class="s2">elif </span><span class="s1">value </span><span class="s2">is not False and </span><span class="s1">value </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s3">[</span><span class="s4">&quot;--%s=%s&quot; </span><span class="s3">% (</span><span class="s1">dashify</span><span class="s3">(</span><span class="s1">name</span><span class="s3">), </span><span class="s1">value</span><span class="s3">)]</span>
        <span class="s2">return </span><span class="s3">[]</span>

    <span class="s2">def </span><span class="s1">transform_kwargs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">split_single_char_options</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; List</span><span class="s3">[</span><span class="s1">str</span><span class="s3">]:</span>
        <span class="s5">&quot;&quot;&quot;Transform Python-style kwargs into git command line options.&quot;&quot;&quot;</span>
        <span class="s1">args </span><span class="s3">= []</span>
        <span class="s2">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">kwargs</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, (</span><span class="s1">list</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">)):</span>
                <span class="s2">for </span><span class="s1">value </span><span class="s2">in </span><span class="s1">v</span><span class="s3">:</span>
                    <span class="s1">args </span><span class="s3">+= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">transform_kwarg</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">split_single_char_options</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">args </span><span class="s3">+= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">transform_kwarg</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">v</span><span class="s3">, </span><span class="s1">split_single_char_options</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">args</span>

    <span class="s3">@</span><span class="s1">classmethod</span>
    <span class="s2">def </span><span class="s1">_unpack_args</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">arg_list</span><span class="s3">: </span><span class="s1">Sequence</span><span class="s3">[</span><span class="s1">str</span><span class="s3">]) </span><span class="s1">-&gt; List</span><span class="s3">[</span><span class="s1">str</span><span class="s3">]:</span>
        <span class="s1">outlist </span><span class="s3">= []</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">arg_list</span><span class="s3">, (</span><span class="s1">list</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">)):</span>
            <span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">arg_list</span><span class="s3">:</span>
                <span class="s1">outlist</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">.</span><span class="s1">_unpack_args</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">))</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">outlist</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">str</span><span class="s3">(</span><span class="s1">arg_list</span><span class="s3">))</span>

        <span class="s2">return </span><span class="s1">outlist</span>

    <span class="s2">def </span><span class="s1">__call__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s4">&quot;Git&quot;</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Specify command line options to the git executable for a subcommand call. 
 
        :param kwargs: 
            A dict of keyword arguments. 
            These arguments are passed as in :meth:`_call_process`, but will be passed 
            to the git command rather than the subcommand. 
 
        Examples:: 
 
            git(work_tree='/tmp').difftool() 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_git_options </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">transform_kwargs</span><span class="s3">(</span><span class="s1">split_single_char_options</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s2">def </span><span class="s1">_call_process</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">method</span><span class="s3">: </span><span class="s1">str</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">: </span><span class="s2">None</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">: </span><span class="s2">None</span>
    <span class="s3">) </span><span class="s1">-&gt; str</span><span class="s3">: ...  </span><span class="s0"># If no args were given, execute the call with all defaults.</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s2">def </span><span class="s1">_call_process</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">method</span><span class="s3">: </span><span class="s1">str</span><span class="s3">,</span>
        <span class="s1">istream</span><span class="s3">: </span><span class="s1">int</span><span class="s3">,</span>
        <span class="s1">as_process</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s2">True</span><span class="s3">],</span>
        <span class="s3">*</span><span class="s1">args</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">,</span>
        <span class="s3">**</span><span class="s1">kwargs</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; </span><span class="s4">&quot;Git.AutoInterrupt&quot;</span><span class="s3">: ...</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s2">def </span><span class="s1">_call_process</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">method</span><span class="s3">: </span><span class="s1">str</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">: </span><span class="s1">Any</span>
    <span class="s3">) </span><span class="s1">-&gt; Union</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">bytes</span><span class="s3">, </span><span class="s1">Tuple</span><span class="s3">[</span><span class="s1">int</span><span class="s3">, </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">bytes</span><span class="s3">], </span><span class="s1">str</span><span class="s3">], </span><span class="s4">&quot;Git.AutoInterrupt&quot;</span><span class="s3">]: ...</span>

    <span class="s2">def </span><span class="s1">_call_process</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">method</span><span class="s3">: </span><span class="s1">str</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">: </span><span class="s1">Any</span>
    <span class="s3">) </span><span class="s1">-&gt; Union</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">bytes</span><span class="s3">, </span><span class="s1">Tuple</span><span class="s3">[</span><span class="s1">int</span><span class="s3">, </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">bytes</span><span class="s3">], </span><span class="s1">str</span><span class="s3">], </span><span class="s4">&quot;Git.AutoInterrupt&quot;</span><span class="s3">]:</span>
        <span class="s5">&quot;&quot;&quot;Run the given git command with the specified arguments and return the result 
        as a string. 
 
        :param method: 
            The command. Contained ``_`` characters will be converted to hyphens, such 
            as in ``ls_files`` to call ``ls-files``. 
 
        :param args: 
            The list of arguments. If ``None`` is included, it will be pruned. 
            This allows your commands to call git more conveniently, as ``None`` is 
            realized as non-existent. 
 
        :param kwargs: 
            Contains key-values for the following: 
 
            - The :meth:`execute()` kwds, as listed in ``execute_kwargs``. 
            - &quot;Command options&quot; to be converted by :meth:`transform_kwargs`. 
            - The ``insert_kwargs_after`` key which its value must match one of 
              ``*args``. 
 
            It also contains any command options, to be appended after the matched arg. 
 
        Examples:: 
 
            git.rev_list('master', max_count=10, header=True) 
 
        turns into:: 
 
            git rev-list max-count 10 --header master 
 
        :return: 
            Same as :meth:`execute`. If no args are given, used :meth:`execute`'s 
            default (especially ``as_process = False``, ``stdout_as_string = True``) and 
            return :class:`str`. 
        &quot;&quot;&quot;</span>
        <span class="s0"># Handle optional arguments prior to calling transform_kwargs.</span>
        <span class="s0"># Otherwise these'll end up in args, which is bad.</span>
        <span class="s1">exec_kwargs </span><span class="s3">= {</span><span class="s1">k</span><span class="s3">: </span><span class="s1">v </span><span class="s2">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">kwargs</span><span class="s3">.</span><span class="s1">items</span><span class="s3">() </span><span class="s2">if </span><span class="s1">k </span><span class="s2">in </span><span class="s1">execute_kwargs</span><span class="s3">}</span>
        <span class="s1">opts_kwargs </span><span class="s3">= {</span><span class="s1">k</span><span class="s3">: </span><span class="s1">v </span><span class="s2">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">kwargs</span><span class="s3">.</span><span class="s1">items</span><span class="s3">() </span><span class="s2">if </span><span class="s1">k </span><span class="s2">not in </span><span class="s1">execute_kwargs</span><span class="s3">}</span>

        <span class="s1">insert_after_this_arg </span><span class="s3">= </span><span class="s1">opts_kwargs</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s4">&quot;insert_kwargs_after&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>

        <span class="s0"># Prepare the argument list.</span>

        <span class="s1">opt_args </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">transform_kwargs</span><span class="s3">(**</span><span class="s1">opts_kwargs</span><span class="s3">)</span>
        <span class="s1">ext_args </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_unpack_args</span><span class="s3">([</span><span class="s1">a </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">args </span><span class="s2">if </span><span class="s1">a </span><span class="s2">is not None</span><span class="s3">])</span>

        <span class="s2">if </span><span class="s1">insert_after_this_arg </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">args_list </span><span class="s3">= </span><span class="s1">opt_args </span><span class="s3">+ </span><span class="s1">ext_args</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">try</span><span class="s3">:</span>
                <span class="s1">index </span><span class="s3">= </span><span class="s1">ext_args</span><span class="s3">.</span><span class="s1">index</span><span class="s3">(</span><span class="s1">insert_after_this_arg</span><span class="s3">)</span>
            <span class="s2">except </span><span class="s1">ValueError </span><span class="s2">as </span><span class="s1">err</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                    <span class="s4">&quot;Couldn't find argument '%s' in args %s to insert cmd options after&quot;</span>
                    <span class="s3">% (</span><span class="s1">insert_after_this_arg</span><span class="s3">, </span><span class="s1">str</span><span class="s3">(</span><span class="s1">ext_args</span><span class="s3">))</span>
                <span class="s3">) </span><span class="s2">from </span><span class="s1">err</span>
            <span class="s0"># END handle error</span>
            <span class="s1">args_list </span><span class="s3">= </span><span class="s1">ext_args</span><span class="s3">[: </span><span class="s1">index </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">] + </span><span class="s1">opt_args </span><span class="s3">+ </span><span class="s1">ext_args</span><span class="s3">[</span><span class="s1">index </span><span class="s3">+ </span><span class="s6">1 </span><span class="s3">:]</span>
        <span class="s0"># END handle opts_kwargs</span>

        <span class="s1">call </span><span class="s3">= [</span><span class="s1">self</span><span class="s3">.</span><span class="s1">GIT_PYTHON_GIT_EXECUTABLE</span><span class="s3">]</span>

        <span class="s0"># Add persistent git options.</span>
        <span class="s1">call</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_persistent_git_options</span><span class="s3">)</span>

        <span class="s0"># Add the git options, then reset to empty to avoid side effects.</span>
        <span class="s1">call</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_git_options</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_git_options </span><span class="s3">= ()</span>

        <span class="s1">call</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">dashify</span><span class="s3">(</span><span class="s1">method</span><span class="s3">))</span>
        <span class="s1">call</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">(</span><span class="s1">args_list</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">execute</span><span class="s3">(</span><span class="s1">call</span><span class="s3">, **</span><span class="s1">exec_kwargs</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_parse_object_header</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">header_line</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; Tuple</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">str</span><span class="s3">, </span><span class="s1">int</span><span class="s3">]:</span>
        <span class="s5">&quot;&quot;&quot; 
        :param header_line: 
            A line of the form:: 
 
                &lt;hex_sha&gt; type_string size_as_int 
 
        :return: 
            (hex_sha, type_string, size_as_int) 
 
        :raise ValueError: 
            If the header contains indication for an error due to incorrect input sha. 
        &quot;&quot;&quot;</span>
        <span class="s1">tokens </span><span class="s3">= </span><span class="s1">header_line</span><span class="s3">.</span><span class="s1">split</span><span class="s3">()</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">tokens</span><span class="s3">) != </span><span class="s6">3</span><span class="s3">:</span>
            <span class="s2">if not </span><span class="s1">tokens</span><span class="s3">:</span>
                <span class="s1">err_msg </span><span class="s3">= (</span>
                    <span class="s4">f&quot;SHA is empty, possible dubious ownership in the repository &quot;</span>
                    <span class="s4">f&quot;&quot;&quot;at </span><span class="s2">{</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_working_dir</span><span class="s2">}</span><span class="s4">.</span><span class="s2">\n            </span><span class="s4">If this is unintended run:</span><span class="s2">\n\n         </span><span class="s4">&quot;&quot;&quot;</span>
                    <span class="s4">f&quot;&quot;&quot;             &quot;git config --global --add safe.directory </span><span class="s2">{</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_working_dir</span><span class="s2">}</span><span class="s4">&quot; &quot;&quot;&quot;</span>
                <span class="s3">)</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">err_msg</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;SHA %s could not be resolved, git returned: %r&quot; </span><span class="s3">% (</span><span class="s1">tokens</span><span class="s3">[</span><span class="s6">0</span><span class="s3">], </span><span class="s1">header_line</span><span class="s3">.</span><span class="s1">strip</span><span class="s3">()))</span>
            <span class="s0"># END handle actual return value</span>
        <span class="s0"># END error handling</span>

        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">tokens</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]) != </span><span class="s6">40</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Failed to parse header: %r&quot; </span><span class="s3">% </span><span class="s1">header_line</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s3">(</span><span class="s1">tokens</span><span class="s3">[</span><span class="s6">0</span><span class="s3">], </span><span class="s1">tokens</span><span class="s3">[</span><span class="s6">1</span><span class="s3">], </span><span class="s1">int</span><span class="s3">(</span><span class="s1">tokens</span><span class="s3">[</span><span class="s6">2</span><span class="s3">]))</span>

    <span class="s2">def </span><span class="s1">_prepare_ref</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">ref</span><span class="s3">: </span><span class="s1">AnyStr</span><span class="s3">) </span><span class="s1">-&gt; bytes</span><span class="s3">:</span>
        <span class="s0"># Required for command to separate refs on stdin, as bytes.</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">ref</span><span class="s3">, </span><span class="s1">bytes</span><span class="s3">):</span>
            <span class="s0"># Assume 40 bytes hexsha - bin-to-ascii for some reason returns bytes, not text.</span>
            <span class="s1">refstr</span><span class="s3">: </span><span class="s1">str </span><span class="s3">= </span><span class="s1">ref</span><span class="s3">.</span><span class="s1">decode</span><span class="s3">(</span><span class="s4">&quot;ascii&quot;</span><span class="s3">)</span>
        <span class="s2">elif not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">ref</span><span class="s3">, </span><span class="s1">str</span><span class="s3">):</span>
            <span class="s1">refstr </span><span class="s3">= </span><span class="s1">str</span><span class="s3">(</span><span class="s1">ref</span><span class="s3">)  </span><span class="s0"># Could be ref-object.</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">refstr </span><span class="s3">= </span><span class="s1">ref</span>

        <span class="s2">if not </span><span class="s1">refstr</span><span class="s3">.</span><span class="s1">endswith</span><span class="s3">(</span><span class="s4">&quot;</span><span class="s2">\n</span><span class="s4">&quot;</span><span class="s3">):</span>
            <span class="s1">refstr </span><span class="s3">+= </span><span class="s4">&quot;</span><span class="s2">\n</span><span class="s4">&quot;</span>
        <span class="s2">return </span><span class="s1">refstr</span><span class="s3">.</span><span class="s1">encode</span><span class="s3">(</span><span class="s1">defenc</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_get_persistent_cmd</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">attr_name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">, </span><span class="s1">cmd_name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s4">&quot;Git.AutoInterrupt&quot;</span><span class="s3">:</span>
        <span class="s1">cur_val </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">attr_name</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">cur_val </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">cur_val</span>

        <span class="s1">options </span><span class="s3">= {</span><span class="s4">&quot;istream&quot;</span><span class="s3">: </span><span class="s1">PIPE</span><span class="s3">, </span><span class="s4">&quot;as_process&quot;</span><span class="s3">: </span><span class="s2">True</span><span class="s3">}</span>
        <span class="s1">options</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">kwargs</span><span class="s3">)</span>

        <span class="s1">cmd </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_call_process</span><span class="s3">(</span><span class="s1">cmd_name</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">options</span><span class="s3">)</span>
        <span class="s1">setattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">attr_name</span><span class="s3">, </span><span class="s1">cmd</span><span class="s3">)</span>
        <span class="s1">cmd </span><span class="s3">= </span><span class="s1">cast</span><span class="s3">(</span><span class="s4">&quot;Git.AutoInterrupt&quot;</span><span class="s3">, </span><span class="s1">cmd</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">cmd</span>

    <span class="s2">def </span><span class="s1">__get_object_header</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">cmd</span><span class="s3">: </span><span class="s4">&quot;Git.AutoInterrupt&quot;</span><span class="s3">, </span><span class="s1">ref</span><span class="s3">: </span><span class="s1">AnyStr</span><span class="s3">) </span><span class="s1">-&gt; Tuple</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">str</span><span class="s3">, </span><span class="s1">int</span><span class="s3">]:</span>
        <span class="s2">if </span><span class="s1">cmd</span><span class="s3">.</span><span class="s1">stdin </span><span class="s2">and </span><span class="s1">cmd</span><span class="s3">.</span><span class="s1">stdout</span><span class="s3">:</span>
            <span class="s1">cmd</span><span class="s3">.</span><span class="s1">stdin</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_prepare_ref</span><span class="s3">(</span><span class="s1">ref</span><span class="s3">))</span>
            <span class="s1">cmd</span><span class="s3">.</span><span class="s1">stdin</span><span class="s3">.</span><span class="s1">flush</span><span class="s3">()</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_parse_object_header</span><span class="s3">(</span><span class="s1">cmd</span><span class="s3">.</span><span class="s1">stdout</span><span class="s3">.</span><span class="s1">readline</span><span class="s3">())</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;cmd stdin was empty&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">get_object_header</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">ref</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; Tuple</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">str</span><span class="s3">, </span><span class="s1">int</span><span class="s3">]:</span>
        <span class="s5">&quot;&quot;&quot;Use this method to quickly examine the type and size of the object behind the 
        given ref. 
 
        :note: 
            The method will only suffer from the costs of command invocation once and 
            reuses the command in subsequent calls. 
 
        :return: 
            (hexsha, type_string, size_as_int) 
        &quot;&quot;&quot;</span>
        <span class="s1">cmd </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_persistent_cmd</span><span class="s3">(</span><span class="s4">&quot;cat_file_header&quot;</span><span class="s3">, </span><span class="s4">&quot;cat_file&quot;</span><span class="s3">, </span><span class="s1">batch_check</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__get_object_header</span><span class="s3">(</span><span class="s1">cmd</span><span class="s3">, </span><span class="s1">ref</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">get_object_data</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">ref</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; Tuple</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">str</span><span class="s3">, </span><span class="s1">int</span><span class="s3">, </span><span class="s1">bytes</span><span class="s3">]:</span>
        <span class="s5">&quot;&quot;&quot;Similar to :meth:`get_object_header`, but returns object data as well. 
 
        :return: 
            (hexsha, type_string, size_as_int, data_string) 
 
        :note: 
            Not threadsafe. 
        &quot;&quot;&quot;</span>
        <span class="s1">hexsha</span><span class="s3">, </span><span class="s1">typename</span><span class="s3">, </span><span class="s1">size</span><span class="s3">, </span><span class="s1">stream </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">stream_object_data</span><span class="s3">(</span><span class="s1">ref</span><span class="s3">)</span>
        <span class="s1">data </span><span class="s3">= </span><span class="s1">stream</span><span class="s3">.</span><span class="s1">read</span><span class="s3">(</span><span class="s1">size</span><span class="s3">)</span>
        <span class="s2">del </span><span class="s1">stream</span>
        <span class="s2">return </span><span class="s3">(</span><span class="s1">hexsha</span><span class="s3">, </span><span class="s1">typename</span><span class="s3">, </span><span class="s1">size</span><span class="s3">, </span><span class="s1">data</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">stream_object_data</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">ref</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; Tuple</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">str</span><span class="s3">, </span><span class="s1">int</span><span class="s3">, </span><span class="s4">&quot;Git.CatFileContentStream&quot;</span><span class="s3">]:</span>
        <span class="s5">&quot;&quot;&quot;Similar to :meth:`get_object_data`, but returns the data as a stream. 
 
        :return: 
            (hexsha, type_string, size_as_int, stream) 
 
        :note: 
            This method is not threadsafe. You need one independent :class:`Git` 
            instance per thread to be safe! 
        &quot;&quot;&quot;</span>
        <span class="s1">cmd </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_persistent_cmd</span><span class="s3">(</span><span class="s4">&quot;cat_file_all&quot;</span><span class="s3">, </span><span class="s4">&quot;cat_file&quot;</span><span class="s3">, </span><span class="s1">batch</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
        <span class="s1">hexsha</span><span class="s3">, </span><span class="s1">typename</span><span class="s3">, </span><span class="s1">size </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__get_object_header</span><span class="s3">(</span><span class="s1">cmd</span><span class="s3">, </span><span class="s1">ref</span><span class="s3">)</span>
        <span class="s1">cmd_stdout </span><span class="s3">= </span><span class="s1">cmd</span><span class="s3">.</span><span class="s1">stdout </span><span class="s2">if </span><span class="s1">cmd</span><span class="s3">.</span><span class="s1">stdout </span><span class="s2">is not None else </span><span class="s1">io</span><span class="s3">.</span><span class="s1">BytesIO</span><span class="s3">()</span>
        <span class="s2">return </span><span class="s3">(</span><span class="s1">hexsha</span><span class="s3">, </span><span class="s1">typename</span><span class="s3">, </span><span class="s1">size</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">CatFileContentStream</span><span class="s3">(</span><span class="s1">size</span><span class="s3">, </span><span class="s1">cmd_stdout</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">clear_cache</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s4">&quot;Git&quot;</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Clear all kinds of internal caches to release resources. 
 
        Currently persistent commands will be interrupted. 
 
        :return: 
            self 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">cmd </span><span class="s2">in </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">cat_file_all</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">cat_file_header</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">cmd</span><span class="s3">:</span>
                <span class="s1">cmd</span><span class="s3">.</span><span class="s1">__del__</span><span class="s3">()</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">cat_file_all </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">cat_file_header </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s2">return </span><span class="s1">self</span>
</pre>
</body>
</html>